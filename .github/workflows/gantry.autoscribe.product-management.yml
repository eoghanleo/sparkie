name: "gantry.autoscribe.product-management"

on:
  push:
    branches: [main]
    paths:
      - "phosphene/signals/bus.jsonl"
  workflow_dispatch:
    inputs:
      upstream_work_id:
        description: "Optional upstream work_id (for issue context only)"
        required: false
        type: string
        default: ""
      work_id:
        description: "Work ID (optional; if empty, allocate next PRD-###)"
        required: false
        type: string
        default: ""
      lane:
        description: "Lane"
        required: false
        type: choice
        options: ["cerulean"]
        default: "cerulean"
      intent:
        description: "Intent string for the work"
        required: false
        type: string
        default: "prd-development"
      parent_signal_id:
        description: "Parent signal_id from bus.jsonl (optional)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: read
  issues: write

env:
  # Gantry write boundary (when/if enabled): signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**

concurrency:
  group: instrument-autoscribe-product-management-${{ github.sha || github.run_id }}
  cancel-in-progress: false

jobs:
  autoscribe_product_management_from_product_marketing_merge:
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v5
        with:
          ref: main
          fetch-depth: 0
          persist-credentials: false

      - name: Load done score config
        id: config
        shell: bash
        run: |
          set -euo pipefail
          done_score_min="$(bash phosphene/phosphene-core/bin/phosphene_config.sh get --color cerulean --key product-management.done_score_min --default 80)"
          [[ -n "${done_score_min:-}" ]] || done_score_min="80"
          echo "done_score_min=$done_score_min" >> "$GITHUB_OUTPUT"
          echo "PHOSPHENE_DONE_SCORE_MIN=$done_score_min" >> "$GITHUB_ENV"

      - name: Extract newly added bus lines
        id: diff
        if: github.event_name == 'push'
        shell: bash
        run: |
          set -euo pipefail
          bus="phosphene/signals/bus.jsonl"
          before="${{ github.event.before }}"
          after="${{ github.sha }}"
          git diff --unified=0 "$before" "$after" -- "$bus" \
            | grep -E '^\+' \
            | grep -vE '^\+\+\+' \
            | sed -E 's/^\+//' \
            | grep -E '^\{' \
            > /tmp/new_lines.txt || true
          echo "count=$(wc -l < /tmp/new_lines.txt | tr -d ' ')" >> "$GITHUB_OUTPUT"

      - name: Validate signal bus tamper hash (JSONL)
        if: github.event_name != 'push' || steps.diff.outputs.count != '0'
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "push" ]]; then
            fail=0
            while IFS= read -r line; do
              [[ -n "${line:-}" ]] || continue
              bash phosphene/phosphene-core/bin/signal_tamper_hash.sh validate-line "$line" >/dev/null 2>&1 || fail=1
            done < /tmp/new_lines.txt
            [[ "$fail" -eq 0 ]]
          else
            bash phosphene/phosphene-core/bin/signal_bus.sh validate --bus phosphene/signals/bus.jsonl
          fi

      - name: Create product-management issue(s) from upstream signal(s)
        id: autoscribe
        uses: actions/github-script@v7
        env:
          PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}
        with:
          script: |
            const fs = require("fs");
            const { execFileSync } = require("child_process");
            const { owner, repo } = context.repo;

            const humanToken = String(process.env.PHOSPHENE_HUMAN_TOKEN || "").trim();
            const apiBase = String(process.env.GITHUB_API_URL || "https://api.github.com").replace(/\/+$/, "");
            const apiHeaders = (token) => ({
              accept: "application/vnd.github+json",
              "content-type": "application/json",
              authorization: `token ${token}`,
              "x-github-api-version": "2022-11-28",
            });
            const apiJson = async (path, { method, token, body }) => {
              const resp = await fetch(`${apiBase}${path}`, {
                method,
                headers: apiHeaders(token),
                body: body ? JSON.stringify(body) : undefined,
              });
              const text = await resp.text();
              if (!resp.ok) throw new Error(`GitHub API ${method} ${path} failed: ${resp.status} ${resp.statusText} :: ${text}`);
              return text ? JSON.parse(text) : null;
            };

            const createIssue = async ({ title, body, labels }) => {
              if (humanToken) {
                return await apiJson(`/repos/${owner}/${repo}/issues`, { method: "POST", token: humanToken, body: { title, body, labels } });
              }
              const resp = await github.rest.issues.create({ owner, repo, title, body, labels });
              return resp.data;
            };

            const busPath = "phosphene/signals/bus.jsonl";
            const templatePath = ".github/prompts/domain_delegation_prompt.md";
            if (!fs.existsSync(templatePath)) throw new Error(`Missing template file: ${templatePath}`);
            const template = fs.readFileSync(templatePath, "utf8");

            const busLines = fs.existsSync(busPath)
              ? fs.readFileSync(busPath, "utf8").split(/\r?\n/).map((l) => l.trim()).filter(Boolean)
              : [];

            const busHasIssueCreatedForParent = (parent_signal_id) => {
              if (!parent_signal_id) return false;
              for (let i = busLines.length - 1; i >= 0; i--) {
                try {
                  const j = JSON.parse(busLines[i]);
                  if (j?.signal_type !== "phosphene.autoscribe.product-management.issue_created.v1") continue;
                  const parents = Array.isArray(j.parents) ? j.parents : [];
                  if (parents.includes(parent_signal_id)) return true;
                } catch {}
              }
              return false;
            };

            const parseRequestSignal = (signalType) => {
              const m = String(signalType || "").match(/^phosphene\.request\.([^.]+)\.([^.]+)\.([^.]+)\.v1$/);
              if (!m) return null;
              return { requestingDomain: m[1], targetDomain: m[2], workType: m[3] };
            };

            const allocatePrdId = () => {
              // Allocate PRD-### safely without writing phosphene/id_index.tsv.
              // Prefer scanning existing PRD bundle directories.
              const prdsRoot = "phosphene/domains/product-management/output/prds";
              let max = 0;
              try {
                if (fs.existsSync(prdsRoot)) {
                  const entries = fs.readdirSync(prdsRoot, { withFileTypes: true });
                  for (const e of entries) {
                    if (!e.isDirectory()) continue;
                    const m = String(e.name || "").match(/^PRD-(\d{3})-/);
                    if (!m) continue;
                    const n = Number(m[1] || 0);
                    if (Number.isFinite(n) && n > max) max = n;
                  }
                }
              } catch {}
              const next = max + 1;
              return `PRD-${String(next).padStart(3, "0")}`;
            };

            const createPmIssueAndEmit = async ({ upstream_work_id, work_id, lane, intent, parent_signal_id, upstream_domain, pointers }) => {
              const resolvedLane = String(lane || "cerulean").trim().toLowerCase();
              const resolvedIntent = String(intent || "prd-development").trim();
              const resolvedParentSignalId = String(parent_signal_id || "").trim();
              const resolvedUpstreamWorkId = String(upstream_work_id || "").trim();
              const resolvedWorkId = String(work_id || "").trim() || allocatePrdId();
              const resolvedUpstreamDomain = String(upstream_domain || "product-marketing").trim() || "product-marketing";

              if (resolvedLane !== "cerulean") throw new Error(`product-management lane must be cerulean (got: ${resolvedLane})`);
              if (!resolvedWorkId) return null;

              if (resolvedParentSignalId && busHasIssueCreatedForParent(resolvedParentSignalId)) {
                core.notice(`PHOSPHENE: autoscribe already emitted issue_created for parent_signal_id=${resolvedParentSignalId} (skip).`);
                return null;
              }

              const dedupeMarker = resolvedParentSignalId
                ? `phosphene-signal-id:${resolvedParentSignalId}`
                : `phosphene-autoscribe:product-management:work_id:${resolvedWorkId}`;

              const search = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} "${dedupeMarker}" in:body type:issue`,
                per_page: 5,
              });
              if (search.data.items.length > 0) {
                core.notice(`PHOSPHENE: issue already exists for ${resolvedWorkId} (dedupe hit).`);
                return null;
              }

              const domainTag = "<product-management>";
              const upstreamDomainTag = `<${resolvedUpstreamDomain}>`;
              const domainSkillPath = ".codex/skills/phosphene/cerulean/product-management/modulator/SKILL.md";
              const domainScriptsPath = ".codex/skills/phosphene/cerulean/product-management/modulator/scripts/";
              const doneScoreMin = String(process.env.PHOSPHENE_DONE_SCORE_MIN || "80").trim();
              const domainDoneScoreCmd = `./.github/scripts/product-management-domain-done-score.sh <bundle_dir> --min-score ${doneScoreMin}`;

              const pointerLines = Array.isArray(pointers) && pointers.length
                ? pointers
                : [
                    "- Use `phosphene/id_index.tsv` to locate upstream artifacts by ID.",
                    resolvedUpstreamWorkId ? `- Upstream work_id: \`${resolvedUpstreamWorkId}\`` : "- Upstream work_id: (unknown; see upstream merge_complete signal)",
                  ];

              const phospheneBlock = [
                "[PHOSPHENE]",
                `lane: ${resolvedLane}`,
                "work_type: product-management",
                `work_id: ${resolvedWorkId}`,
                `intent: ${resolvedIntent}`,
                "depends_on:",
                "sequence:",
                `upstream_signal_id: ${resolvedParentSignalId || ""}`.trimEnd(),
                "[/PHOSPHENE]",
              ].join("\n");

              const titleUpstream = (resolvedUpstreamWorkId && resolvedUpstreamWorkId !== resolvedWorkId)
                ? ` (${resolvedUpstreamWorkId})`
                : "";
              const issueTitle = `PHOSPHENE: <product-management> PRD development for ${resolvedWorkId}${titleUpstream}`;

              const body = [
                phospheneBlock,
                "",
                template
                  .replaceAll("{{UPSTREAM_PR_NUMBER}}", "N/A")
                  .replaceAll("{{UPSTREAM_PR_TITLE}}", "(merge-signal triggered; no PR context)")
                  .replaceAll("{{UPSTREAM_PR_URL}}", "(n/a)")
                  .replaceAll("{{UPSTREAM_WORK_ID}}", resolvedUpstreamWorkId || "(unknown)")
                  .replaceAll("{{SIGNAL_PATH}}", resolvedParentSignalId ? `phosphene/signals/bus.jsonl#${resolvedParentSignalId}` : "phosphene/signals/bus.jsonl")
                  .replaceAll("{{UPSTREAM_DOMAIN_TAG}}", upstreamDomainTag)
                  .replaceAll("{{DOMAIN_TAG}}", domainTag)
                  .replaceAll("{{DOMAIN_SKILL_PATH}}", domainSkillPath)
                  .replaceAll("{{DOMAIN_SCRIPTS_PATH}}", domainScriptsPath)
                  .replaceAll("{{DOMAIN_DONE_SIGNAL_PATH}}", "phosphene/signals/bus.jsonl (DONE receipt line)")
                  .replaceAll("{{DONE_SCORE_MIN}}", doneScoreMin)
                  .replaceAll("{{DOMAIN_DONE_SCORE_CMD}}", domainDoneScoreCmd)
                  .replaceAll("{{INTENT}}", resolvedIntent)
                  .replaceAll("{{POINTERS_BULLETS}}", pointerLines.join("\n"))
                  .replaceAll("{{NOTES_BLOCK}}", "")
                  .replaceAll("{{PHOSPHENE_DEDUPE_MARKER}}", dedupeMarker),
              ].join("\n");

              const labels = [
                "phosphene",
                `phosphene:${resolvedLane}`,
                "phosphene:domain:product-management",
                "phosphene:instrument:autoscribe",
                "phosphene:ready",
              ];

              const issue = await createIssue({ title: issueTitle, body, labels });
              core.notice(`PHOSPHENE: created product-management issue #${issue.number}: ${issue.html_url}`);

              const created_utc = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
              const output_key = `autoscribe:issue-created:product-management:issue:${issue.number}`;
              const hashArgs = [
                "phosphene/phosphene-core/bin/signal_hash.sh",
                "signal-id",
                "--run-marker",
                resolvedWorkId,
                "--output-key",
                output_key,
              ];
              if (resolvedParentSignalId) hashArgs.push("--parent", resolvedParentSignalId);
              const signal_id = String(execFileSync("bash", hashArgs, { encoding: "utf8" })).trim();

              const sig = {
                signal_version: 1,
                signal_id,
                signal_type: "phosphene.autoscribe.product-management.issue_created.v1",
                work_id: resolvedWorkId,
                domain: "product-management",
                issue_number: issue.number,
                lane: resolvedLane,
                intent: resolvedIntent,
                phos_id: "",
                parents: resolvedParentSignalId ? [resolvedParentSignalId] : [],
                run_marker: resolvedWorkId,
                output_key,
                created_utc,
              };

              execFileSync("bash", [
                "phosphene/phosphene-core/bin/signal_bus.sh",
                "append",
                "--bus",
                busPath,
                "--line",
                JSON.stringify(sig),
              ], { stdio: "inherit" });

              return { issue_number: issue.number, work_id: resolvedWorkId, signal_id };
            };

            const created = [];
            if (context.eventName === "workflow_dispatch") {
              const upstream_work_id = String(core.getInput("upstream_work_id") || "").trim();
              const work_id = String(core.getInput("work_id") || "").trim();
              const lane = String(core.getInput("lane") || "cerulean").trim().toLowerCase();
              const intent = String(core.getInput("intent") || "prd-development").trim();
              const parent_signal_id = String(core.getInput("parent_signal_id") || "").trim();
              const out = await createPmIssueAndEmit({ upstream_work_id, work_id, lane, intent, parent_signal_id });
              if (out) created.push(out);
            } else if (context.eventName === "push") {
              const raw = fs.existsSync("/tmp/new_lines.txt") ? fs.readFileSync("/tmp/new_lines.txt", "utf8") : "";
              const lines = raw.split(/\n/).filter(Boolean);
              for (const line of lines) {
                let j;
                try { j = JSON.parse(line); } catch { continue; }
                const req = parseRequestSignal(j.signal_type);
                if (req && req.targetDomain === "product-management") {
                  const work_id = String(j.work_id || "").trim();
                  if (!work_id) continue;
                  const parent_signal_id = String(j.signal_id || "").trim();
                  const upstream_domain = String(j.domain || req.requestingDomain || "").trim();
                  const issue_number = Number(j.issue_number || 0);
                  const intent = req.workType ? req.workType : "prd-development";
                  const pointers = [
                    upstream_domain ? `- Requesting domain: <${upstream_domain}>` : "- Requesting domain: (unknown)",
                    issue_number ? `- Requesting issue: #${issue_number}` : "- Requesting issue: (n/a)",
                    `- Requested work_id: \`${work_id}\``,
                  ];
                  const out = await createPmIssueAndEmit({
                    upstream_work_id: work_id,
                    work_id,
                    lane: "cerulean",
                    intent,
                    parent_signal_id,
                    upstream_domain,
                    pointers,
                  });
                  if (out) created.push(out);
                  continue;
                }

                if (String(j.signal_type || "") !== "phosphene.merge_complete.product-marketing.v1") continue;
                const parent_signal_id = String(j.signal_id || "").trim();
                const upstream_work_id = String(j.work_id || "").trim();
                const out = await createPmIssueAndEmit({
                  upstream_work_id,
                  work_id: "",
                  lane: "cerulean",
                  intent: "prd-development",
                  parent_signal_id,
                });
                if (out) created.push(out);
              }
            }

            if (created.length === 0) {
              core.notice("PHOSPHENE: no autoscribe work performed (no matching signals or all deduped).");
              return;
            }

            core.setOutput("did_append", "1");
            core.setOutput("issues", created.map((c) => String(c.issue_number)).join(","));
            core.notice(`PHOSPHENE: autoscribed issues: ${created.map((c) => `#${c.issue_number}`).join(", ")}`);

      - name: Commit + push bus append
        if: steps.autoscribe.outputs.did_append == '1'
        shell: bash
        env:
          PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}
        run: |
          set -euo pipefail

          export PHOSPHENE_GANTRY_WRITE_ALLOWLIST=$'phosphene/signals/**\nphosphene/signals/indexes/**'
          bash phosphene/phosphene-core/bin/gantry_write_allowlist_guard.sh check

          if [[ -z "${PHOSPHENE_HUMAN_TOKEN:-}" ]]; then
            echo "PHOSPHENE: missing PHOSPHENE_HUMAN_TOKEN; refusing to push bus changes (would suppress downstream workflows)."
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${PHOSPHENE_HUMAN_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

          if git diff --quiet -- "phosphene/signals/bus.jsonl"; then
            echo "PHOSPHENE: bus.jsonl unchanged; nothing to commit."
            exit 0
          fi

          git add "phosphene/signals/bus.jsonl"
          git commit -m "PHOSPHENE: autoscribe product-management issue_created for issue(s) ${{ steps.autoscribe.outputs.issues }}"
          git push origin HEAD:main

