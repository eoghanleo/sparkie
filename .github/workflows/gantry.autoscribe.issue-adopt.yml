name: "gantry.autoscribe.issue-adopt"

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      mode:
        description: "help: comment usage; tidy: normalize issue only; adopt: tidy + emit autoscribe issue_created signal to bus"
        required: true
        type: choice
        options: ["help", "tidy", "adopt"]
        default: "tidy"
      domain:
        description: "Target domain to enforce (sets color label + work_type + labels)"
        required: true
        type: choice
        options:
          - "research"
          - "product-marketing"
          - "product-management"
          - "ideation"
          - "product-vision"
          - "product-strategy"
          - "product-architecture"
          - "product-evaluation"
          - "feature-management"
          - "test-management"
          - "scrum-management"
      issue_number:
        description: "Issue number to tidy/adopt"
        required: true
        type: number
      work_id:
        description: "Work ID to set in [PHOSPHENE] block (optional; will attempt to infer/allocate)"
        required: false
        type: string
        default: ""
      intent:
        description: "Intent string to set in [PHOSPHENE] block (optional)"
        required: false
        type: string
        default: ""
      upstream_signal_id:
        description: "Optional upstream signal_id (sha256:...) to embed as upstream_signal_id"
        required: false
        type: string
        default: ""

permissions:
  actions: write
  issues: write
  contents: write

env:
  # Gantry write boundary: signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**
  PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}

concurrency:
  group: instrument-autoscribe-issue-adopt-${{ inputs.issue_number || github.run_id }}
  cancel-in-progress: true

jobs:
  tidy_and_optionally_adopt:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v5
        with:
          ref: main
          fetch-depth: 0
          persist-credentials: false

      - name: Tidy issue into strict [PHOSPHENE] (and optionally emit bus signal)
        id: tidy
        uses: actions/github-script@v7
        with:
          script: |
            const { execFileSync } = require("child_process");
            const fs = require("fs");
            const crypto = require("crypto");
            const { owner, repo } = context.repo;

            const eventName = String(context.eventName || "");

            // --- command parsing helpers (issue_comment mode) ---
            const stripTicks = (s) => String(s || "").trim().replace(/^`+|`+$/g, "");
            const parseFlag = (text, name) => {
              const t = String(text || "");
              const re1 = new RegExp(`(?:^|\\s)--${name}\\s+\\"([^\\"]*)\\"`);
              const re2 = new RegExp(`(?:^|\\s)--${name}\\s+'([^']*)'`);
              const re3 = new RegExp(`(?:^|\\s)--${name}\\s+([^\\s]+)`);
              let m = t.match(re1); if (m) return stripTicks(m[1]);
              m = t.match(re2); if (m) return stripTicks(m[1]);
              m = t.match(re3); if (m) return stripTicks(m[1]);
              return "";
            };
            const pickCommandLine = (commentBody) => {
              const lines = String(commentBody || "").split(/\r?\n/);
              for (const line of lines) {
                const l = String(line || "").trim();
                if (!l) continue;
                if (l.startsWith("/phosphene autoscribe")) return l;
                if (l.startsWith("@phosphene autoscribe")) return l;
                // tolerate extra prefix words
                if (/\b\/phosphene\s+autoscribe\b/.test(l)) return l.slice(l.indexOf("/phosphene"));
                if (/\b@phosphene\s+autoscribe\b/.test(l)) return l.slice(l.indexOf("@phosphene"));
              }
              return "";
            };

            // Resolve inputs either from workflow_dispatch or issue_comment command.
            let mode = "";
            let domain = "";
            let issue_number = 0;
            let workIdInput = "";
            let intentInput = "";
            let upstreamSignalIdInput = "";

            if (eventName === "workflow_dispatch") {
              mode = String(core.getInput("mode", { required: true }) || "").trim();
              domain = String(core.getInput("domain", { required: true }) || "").trim();
              issue_number = Number(core.getInput("issue_number", { required: true }) || 0);
              workIdInput = String(core.getInput("work_id") || "").trim();
              intentInput = String(core.getInput("intent") || "").trim();
              upstreamSignalIdInput = String(core.getInput("upstream_signal_id") || "").trim();
            } else if (eventName === "issue_comment") {
              const isBot = (u) => {
                const login = String(u?.login || "").toLowerCase();
                return Boolean(u?.type === "Bot" || login.endsWith("[bot]") || login === "github-actions");
              };
              if (isBot(context.payload?.comment?.user)) {
                core.notice("PHOSPHENE: ignoring autoscribe command from bot user.");
                core.setOutput("did_append", "0");
                return;
              }

              const assoc = String(context.payload?.comment?.author_association || "").toUpperCase();
              const allowed = new Set(["OWNER", "MEMBER", "COLLABORATOR"]);
              if (!allowed.has(assoc)) {
                core.notice(`PHOSPHENE: ignoring autoscribe command from non-member association: ${assoc || "(unknown)"}`);
                core.setOutput("did_append", "0");
                return;
              }

              const issue = context.payload?.issue;
              if (!issue?.number) {
                core.notice("PHOSPHENE: issue_comment event missing issue.number; no-op.");
                core.setOutput("did_append", "0");
                return;
              }
              if (issue.pull_request) {
                core.notice("PHOSPHENE: ignoring autoscribe command on PR comments (issue_comment on PR).");
                core.setOutput("did_append", "0");
                return;
              }

              issue_number = Number(issue.number || 0);
              const cmdLine = pickCommandLine(context.payload?.comment?.body || "");
              if (!cmdLine) {
                core.notice("PHOSPHENE: no autoscribe command found in comment; no-op.");
                core.setOutput("did_append", "0");
                return;
              }

              // command shape:
              //   /phosphene autoscribe <help|tidy|adopt> --domain <d> [--work-id ...] [--intent "..."] [--upstream-signal-id sha256:...]
              const after = cmdLine.replace(/^(@phosphene|\/phosphene)\s+autoscribe\s+/i, "").trim();
              const action = (after.split(/\s+/)[0] || "").trim().toLowerCase();
              if (!["help", "tidy", "adopt"].includes(action)) {
                await github.rest.issues.createComment({
                  owner, repo, issue_number,
                  body: [
                    "PHOSPHENE AUTOSCRIBE: unknown command.",
                    "",
                    "Try:",
                    "- `/phosphene autoscribe help --domain <domain>`",
                    "- `/phosphene autoscribe tidy --domain <domain> --work-id <ID>`",
                    "- `/phosphene autoscribe adopt --domain <domain> --work-id <ID>`",
                  ].join("\n"),
                });
                core.setOutput("did_append", "0");
                return;
              }
              mode = action;
              domain = parseFlag(after, "domain");
              workIdInput = parseFlag(after, "work-id");
              intentInput = parseFlag(after, "intent");
              upstreamSignalIdInput = parseFlag(after, "upstream-signal-id");

              // Fallback: infer domain from labels if not provided.
              if (!domain) {
                const labels = (issue.labels || []).map((l) => (typeof l === "string" ? l : l?.name)).filter(Boolean).map((s) => String(s));
                for (const lab of labels) {
                  const m = String(lab).match(/^phosphene:domain:(.+)$/i);
                  if (m) { domain = String(m[1] || "").trim(); break; }
                }
              }

              // Ack quickly to make the UX feel like a "summon".
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: [
                  "PHOSPHENE AUTOSCRIBE: command received; processing now.",
                  "",
                  `- mode: \`${mode}\``,
                  `- domain: \`${domain || "(missing)"}\``,
                  workIdInput ? `- work_id (requested): \`${workIdInput}\`` : "- work_id (requested): (n/a)",
                  "",
                  "_Security_: commands are accepted only from repo members/collaborators.",
                ].join("\n"),
              });
            } else {
              core.notice(`PHOSPHENE: unsupported event ${eventName}; no-op.`);
              core.setOutput("did_append", "0");
              return;
            }

            if (!issue_number) throw new Error("Missing/invalid issue_number");
            if (!domain) {
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: [
                  "PHOSPHENE AUTOSCRIBE: missing domain.",
                  "",
                  "Provide it explicitly:",
                  "- `/phosphene autoscribe tidy --domain product-marketing --work-id RA-001`",
                  "",
                  "Or add a label:",
                  "- `phosphene:domain:<domain>`",
                ].join("\n"),
              });
              core.setOutput("did_append", "0");
              return;
            }

            const domainMap = {
              "research": { lane: "viridian", work_type: "research", default_intent: "research-assessment", alloc_type: "ra" },
              "ideation": { lane: "viridian", work_type: "ideation", default_intent: "idea-development", alloc_type: "idea" },

              "product-marketing": { lane: "beryl", work_type: "product-marketing", default_intent: "proposition-development", alloc_type: "ra" },
              "product-vision": { lane: "beryl", work_type: "product-vision", default_intent: "vision-development", alloc_type: "vision" },
              "product-strategy": { lane: "beryl", work_type: "product-strategy", default_intent: "roadmap-development", alloc_type: "roadmap" },

              "product-management": { lane: "cerulean", work_type: "product-management", default_intent: "prd-development", alloc_type: "prd" },
              "product-architecture": { lane: "cerulean", work_type: "product-architecture", default_intent: "architecture-development", alloc_type: "arch" },
              "feature-management": { lane: "cerulean", work_type: "feature-management", default_intent: "feature-request", alloc_type: "fr" },

              "test-management": { lane: "cadmium", work_type: "test-management", default_intent: "test-plan", alloc_type: "tp" },
              "product-evaluation": { lane: "cadmium", work_type: "product-evaluation", default_intent: "evaluation", alloc_type: "eval" },

              "scrum-management": { lane: "amaranth", work_type: "scrum-management", default_intent: "issue-mirror", alloc_type: "" },
            };

            const dm = domainMap[domain];
            if (!dm) throw new Error(`Unsupported domain: ${domain}`);

            const PH_OPEN = "[PHOSPHENE]";
            const PH_CLOSE = "[/PHOSPHENE]";

            const extractBlock = (text) => {
              const openIdx = text.indexOf(PH_OPEN);
              if (openIdx === -1) return null;
              const closeIdx = text.indexOf(PH_CLOSE, openIdx);
              if (closeIdx === -1) return null;
              return {
                openIdx,
                endIdx: closeIdx + PH_CLOSE.length,
                raw: text.slice(openIdx, closeIdx + PH_CLOSE.length),
              };
            };

            const parseKvFromBlock = (rawBlock) => {
              const kv = {};
              const lines = String(rawBlock || "").split(/\r?\n/);
              for (const line of lines) {
                if (!line.includes(":")) continue;
                if (line.trim() === PH_OPEN || line.trim() === PH_CLOSE) continue;
                const m = line.match(/^\s*([a-zA-Z0-9_]+)\s*:\s*(.*?)\s*$/);
                if (!m) continue;
                kv[String(m[1] || "").toLowerCase()] = String(m[2] || "").trim();
              }
              return kv;
            };

            const firstMatch = (s, re) => {
              const m = String(s || "").match(re);
              return m ? String(m[0] || "") : "";
            };

            const inferWorkIdFromText = (text) => {
              const t = String(text || "");
              // Prefer domain-specific patterns, then fallback to "any known PHOSPHENE-ish ID".
              const perDomain = {
                "research": /RA-[0-9]{3}/,
                "product-marketing": /RA-[0-9]{3}/,
                "product-management": /PRD-[0-9]{3}/,
                "ideation": /IDEA-[0-9]{4}/,
                "product-vision": /VISION-[0-9]{3}/,
                "product-strategy": /ROADMAP-[0-9]{3}/,
                "product-architecture": /ARCH-[0-9]{3}/,
                "product-evaluation": /EVAL-[0-9]{3}/,
                "feature-management": /FR-[0-9]{3}/,
                "test-management": /TP-[0-9]{3}/,
                "scrum-management": /ISSUE-[0-9]{3,}/,
              };
              const re = perDomain[domain] || /(RA|PRD|IDEA|VISION|ROADMAP|ARCH|EVAL|FR|TP|ISSUE)-[0-9]{3,4}/;
              return firstMatch(t, re);
            };

            const allocateNextIfPossible = () => {
              const t = String(dm.alloc_type || "").trim();
              if (!t) return "";
              try {
                const out = String(execFileSync("bash", [
                  "phosphene/phosphene-core/bin/phosphene",
                  "id",
                  "next",
                  "--type",
                  t,
                ], { encoding: "utf8" }) || "").trim();
                return out;
              } catch {
                return "";
              }
            };

            const PRIMARY_OBJECTIVE_HEADING = "Primary objective of the ideation task:";
            const isHydratedPrompt = (text) => {
              const t = String(text || "");
              return t.includes("PHOSPHENE — Domain Delegation Prompt (parameterized)")
                || t.includes("SYSTEM: You are a Codex agent operating inside a PHOSPHENE harness repo.")
                || t.includes("PHOSPHENE handoff detected:")
                || t.includes("## Domain behavior and success criteria")
                || t.includes("## Non-negotiable PHOSPHENE contract");
            };
            const extractSection = (text, heading) => {
              const lines = String(text || "").split(/\r?\n/);
              let start = -1;
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim() === heading) { start = i + 1; break; }
              }
              if (start === -1) return "";
              while (start < lines.length && !lines[start].trim()) start++;
              let end = lines.length;
              for (let i = start; i < lines.length; i++) {
                if (/^##\s+/.test(lines[i]) || /^###\s+/.test(lines[i])) { end = i; break; }
              }
              return lines.slice(start, end).join("\n").trim();
            };
            const sanitizePrimaryObjective = (text) => {
              const t = String(text || "").trim();
              if (!t) return "";
              if (isHydratedPrompt(t) || t.includes("SYSTEM:")) return "";
              return t;
            };
            const extractPrimaryObjectiveBlock = (text) => {
              const lines = String(text || "").split(/\r?\n/);
              let start = -1;
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim() === PRIMARY_OBJECTIVE_HEADING) { start = i + 1; break; }
              }
              if (start === -1) return "";
              while (start < lines.length && !lines[start].trim()) start++;
              let end = lines.length;
              for (let i = start; i < lines.length; i++) {
                if (/^##\s+/.test(lines[i]) || /^###\s+/.test(lines[i])) { end = i; break; }
              }
              return lines.slice(start, end).join("\n").trim();
            };
            const stripPrimaryObjectiveBlock = (text) => {
              const lines = String(text || "").split(/\r?\n/);
              const out = [];
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim() === PRIMARY_OBJECTIVE_HEADING) {
                  i++;
                  while (i < lines.length && !lines[i].trim()) i++;
                  while (i < lines.length && !/^##\s+/.test(lines[i]) && !/^###\s+/.test(lines[i])) i++;
                  i -= 1;
                  continue;
                }
                out.push(lines[i]);
              }
              return out.join("\n").trim();
            };

            const canonicalStrictBlock = ({ lane, work_type, work_id, intent, depends_on, sequence, upstream_signal_id, manifold_probe_count }) => {
              const seedInputValues = [
                lane,
                work_type,
                work_id,
                intent,
                depends_on || "",
                sequence || "",
                upstream_signal_id || "",
                String(manifold_probe_count),
              ].join("\n");
              const seed_sha256 = `${crypto.createHash("sha256").update(seedInputValues).digest("hex")}`;
              const lines = [
                PH_OPEN,
                `lane: ${lane}`,
                `work_type: ${work_type}`,
                `work_id: ${work_id}`,
                `intent: ${intent}`,
                `depends_on: ${depends_on || ""}`.trimEnd(),
                `sequence: ${sequence || ""}`.trimEnd(),
                `upstream_signal_id: ${upstream_signal_id || ""}`.trimEnd(),
                `manifold_probe_count: ${manifold_probe_count}`,
                `seed_sha256: ${seed_sha256}`,
                PH_CLOSE,
              ];
              return lines.join("\n");
            };

            const postHelp = async () => {
              const body = [
                "PHOSPHENE AUTOSCRIBE (manual issue tidy/adopt)",
                "",
                "This workflow can normalize a human-made issue into a strict `[PHOSPHENE]` block, add the correct labels, and (optionally) emit the matching `phosphene.autoscribe.<domain>.issue_created.v1` bus signal so hoppers can pick it up.",
                "",
                "## How to use",
                "### In an issue comment (recommended)",
                "- `@phosphene autoscribe help --domain <domain>`",
                "- `@phosphene autoscribe tidy --domain <domain> --work-id <ID>`",
                "- `@phosphene autoscribe adopt --domain <domain> --work-id <ID>`",
                "",
                "Also supported:",
                "- `/phosphene autoscribe ...`",
                "",
                "### Via Actions (workflow_dispatch)",
                `- workflow: \`gantry.autoscribe.issue-adopt\``,
                `- mode: \`tidy\` or \`adopt\``,
                `- domain: \`${domain}\``,
                `- issue_number: \`${issue_number}\``,
                "",
                "## Notes",
                "- `tidy` updates the issue only (no bus write).",
                "- `adopt` tidies the issue AND appends an autoscribe `issue_created` signal to `phosphene/signals/bus.jsonl` on `main` (requires `PHOSPHENE_HUMAN_TOKEN`).",
                "",
                "## CLI (local)",
                "- `./phosphene/phosphene-core/bin/phosphene autoscribe issue adopt --domain <domain> --issue-number <N>`",
                "- `./phosphene/phosphene-core/bin/phosphene autoscribe issue tidy  --domain <domain> --issue-number <N>`",
              ].join("\n");
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            };

            if (mode === "help") {
              await postHelp();
              core.setOutput("did_append", "0");
              return;
            }

            const resp = await github.rest.issues.get({ owner, repo, issue_number });
            const issue = resp.data;
            const title = String(issue?.title || "").trim();
            const body = String(issue?.body || "");
            const existingLabels = (issue.labels || [])
              .map((l) => (typeof l === "string" ? l : l?.name))
              .filter(Boolean)
              .map((s) => String(s));

            const block = extractBlock(body);
            const kv = block ? parseKvFromBlock(block.raw) : {};

            let work_id = workIdInput
              || String(kv.work_id || "").trim()
              || inferWorkIdFromText(title)
              || inferWorkIdFromText(body);
            if (!work_id) {
              work_id = allocateNextIfPossible();
            }

            const intent = intentInput || String(kv.intent || "").trim() || title || dm.default_intent;
            const upstream_signal_id = upstreamSignalIdInput || String(kv.upstream_signal_id || "").trim();
            const manifoldProbeCountRaw = String(kv.manifold_probe_count || "").trim();
            const manifoldProbeCountParsed = Number.parseInt(manifoldProbeCountRaw, 10);
            const manifold_probe_count = Number.isFinite(manifoldProbeCountParsed) && manifoldProbeCountParsed >= 2
              ? manifoldProbeCountParsed
              : 10;

            // Compose updated issue body: replace existing [PHOSPHENE] block if present, else prepend.
            const rest = block ? (body.slice(0, block.openIdx) + body.slice(block.endIdx)).trim() : body.trim();
            const hasTemplateMarker = isHydratedPrompt(rest);
            const restSansPrimary = stripPrimaryObjectiveBlock(rest);

            const strictBlock = canonicalStrictBlock({
              lane: dm.lane,
              work_type: dm.work_type,
              work_id,
              intent,
              depends_on: "",
              sequence: "",
              upstream_signal_id,
              manifold_probe_count,
            });

            const primaryObjectiveRaw = (domain === "ideation")
              ? sanitizePrimaryObjective(extractPrimaryObjectiveBlock(rest) || (!hasTemplateMarker ? restSansPrimary : ""))
              : "";
            const primaryObjectiveText = String(primaryObjectiveRaw || "").trim();
            const primaryObjectiveBlock = primaryObjectiveText
              ? [PRIMARY_OBJECTIVE_HEADING, "", primaryObjectiveText].join("\n")
              : "";
            const hasPrimaryObjective = Boolean(extractPrimaryObjectiveBlock(rest));
            const headerParts = [strictBlock];
            if (!hasPrimaryObjective && primaryObjectiveBlock) {
              headerParts.push("", primaryObjectiveBlock);
            }
            let updatedBody = headerParts.join("\n").trim() + "\n\n" + restSansPrimary;
            updatedBody = updatedBody.trim() + "\n";

            // For ideation, hydrate the canonical prompt template so the issue matches autoscribe output.
            const templatePath = ".github/prompts/domain_delegation_prompt.md";
            const canHydrate = (domain === "ideation") && fs.existsSync(templatePath);
            if (canHydrate && !hasTemplateMarker) {
              const upstreamDomainTag = "<manual>";
              const domainTag = `<${domain}>`;
              const domainSkillPath = ".codex/skills/phosphene/viridian/ideation/modulator/SKILL.md";
              const domainScriptsPath = ".codex/skills/phosphene/viridian/ideation/modulator/scripts/";
              const manifoldProbeCount = manifold_probe_count;

              let doneScoreMin = "10";
              try {
                doneScoreMin = String(execFileSync("bash", [
                  "phosphene/phosphene-core/bin/phosphene_config.sh",
                  "get",
                  "--color",
                  dm.lane,
                  "--key",
                  `${domain}.done_score_min`,
                  "--default",
                  "10",
                ], { encoding: "utf8" }) || "10").trim();
              } catch {}
              if (!doneScoreMin) doneScoreMin = "10";
              const domainDoneScoreCmd = `./.github/scripts/ideation-domain-done-score.sh --file <IDEA_PATH> --min-score ${doneScoreMin}`;

              const pointerLines = [
                `- Manual issue: #${issue_number}`,
                work_id ? `- work_id: \`${work_id}\`` : "- work_id: (missing)",
              ];

              const notesBlock = [
                "## STORM TABLE (mandatory for this run)",
                "",
                "### Intended behavior",
                "- Produce a single IDEA artifact that contains a **Storm table** aligned to the primary objective:",
                `  - Select ${manifoldProbeCount} probes from \`WIP/creative_madness/manifold_probes.jsonl\` using seed_sha256 from the PHOSPHENE block.`,
                "  - Create rows for every unordered probe pair × 3 rings (adjacent/orthogonal/extrapolatory).",
                "  - Columns: STORM-ID, PROBE_1, PROBE_2, RING, DESCRIPTION.",
                "  - DESCRIPTION must be a paragraph (≥ 3 sentences) influenced by PROBE_1 + PROBE_2 + RING; every description must be within the frame and exploring the creative space of the primary objective.",
                "- Use bash scripts to update the storm table (do not hand-edit table rows).",
                "- Run validators + done-score and PASS before writing DONE receipt.",
              ].join("\n").trim();

              const template = fs.readFileSync(templatePath, "utf8");
              const hydrated = template
                .replaceAll("{{UPSTREAM_PR_NUMBER}}", "N/A")
                .replaceAll("{{UPSTREAM_PR_TITLE}}", "(manual autoscribe adopt)")
                .replaceAll("{{UPSTREAM_PR_URL}}", "(n/a)")
                .replaceAll("{{UPSTREAM_WORK_ID}}", work_id || "(unknown)")
                .replaceAll("{{SIGNAL_PATH}}", "phosphene/signals/bus.jsonl")
                .replaceAll("{{UPSTREAM_DOMAIN_TAG}}", upstreamDomainTag)
                .replaceAll("{{DOMAIN_TAG}}", domainTag)
                .replaceAll("{{DOMAIN_SKILL_PATH}}", domainSkillPath)
                .replaceAll("{{DOMAIN_SCRIPTS_PATH}}", domainScriptsPath)
                .replaceAll("{{DOMAIN_DONE_SIGNAL_PATH}}", "phosphene/signals/bus.jsonl (DONE receipt line)")
                .replaceAll("{{DONE_SCORE_MIN}}", doneScoreMin)
                .replaceAll("{{DOMAIN_DONE_SCORE_CMD}}", domainDoneScoreCmd)
                .replaceAll("{{INTENT}}", intent || dm.default_intent)
                .replaceAll("{{POINTERS_BULLETS}}", pointerLines.join("\n"))
                .replaceAll("{{NOTES_BLOCK}}", notesBlock)
                .replaceAll("{{PHOSPHENE_DEDUPE_MARKER}}", `phosphene-autoscribe:manual-issue:${issue_number}`);

              updatedBody = [headerParts.join("\n").trim(), hydrated].join("\n\n").trim() + "\n";
            } else if (canHydrate && hasTemplateMarker) {
              // Already hydrated: avoid re-embedding the template or duplicating sections.
              updatedBody = [headerParts.join("\n").trim(), rest].join("\n\n").trim() + "\n";
            }

            // Labels: always add phosphene + color + domain + instrument; add ready only in adopt mode.
            const want = new Set(existingLabels);
            want.add("phosphene");
            want.add(`phosphene:domain:${domain}`);
            want.add(`phosphene:${dm.lane}`);
            want.add("phosphene:instrument:autoscribe");
            if (mode === "adopt") want.add("phosphene:ready");

            // Apply issue updates.
            await github.rest.issues.update({
              owner,
              repo,
              issue_number,
              body: updatedBody,
              labels: Array.from(want),
            });

            const commentLines = [
              "PHOSPHENE AUTOSCRIBE: issue normalized for reintegration.",
              "",
              `- domain: \`${domain}\``,
              `- lane: \`${dm.lane}\``,
              `- work_type: \`${dm.work_type}\``,
              `- work_id: \`${work_id || "(missing)"}\``,
              `- mode: \`${mode}\``,
              "",
              "Next:",
              "- If mode was `tidy`: run hopper manual evaluation (or rerun this workflow with mode=`adopt`).",
              "- If mode was `adopt`: hoppers will see the bus append and decide eligibility (labels + strict block now in place).",
            ];

            if (!work_id) {
              commentLines.push("", "**WARNING**: work_id could not be inferred or allocated; hopper will treat this as ineligible until work_id is set.");
            }

            const busPath = "phosphene/signals/bus.jsonl";
            const strictBlockHash = crypto.createHash("sha256").update(strictBlock).digest("hex").slice(0, 12);
            const output_key = `autoscribe:issue-adopted:${domain}:issue:${issue_number}:block:${strictBlockHash}`;
            let didAppend = false;
            let signal_id = "";

            if (mode === "adopt" && work_id) {
              // Compute deterministic signal_id (optionally parent upstream_signal_id if it looks like a sha256 id).
              const hashArgs = [
                "phosphene/phosphene-core/bin/signal_hash.sh",
                "signal-id",
                "--run-marker",
                work_id,
                "--output-key",
                output_key,
              ];
              if (/^sha256:[0-9A-Fa-f]{64}$/.test(upstream_signal_id)) {
                hashArgs.push("--parent", upstream_signal_id);
              }
              signal_id = String(execFileSync("bash", hashArgs, { encoding: "utf8" }) || "").trim();

              const busText = fs.existsSync(busPath) ? fs.readFileSync(busPath, "utf8") : "";
              if (!busText.includes(`"signal_id":"${signal_id}"`)) {
                const created_utc = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
                const sig = {
                  signal_version: 1,
                  signal_id,
                  signal_type: `phosphene.autoscribe.${domain}.issue_created.v1`,
                  work_id,
                  domain,
                  issue_number,
                  lane: dm.lane,
                  intent,
                  phos_id: "",
                  parents: (/^sha256:[0-9A-Fa-f]{64}$/.test(upstream_signal_id) ? [upstream_signal_id] : []),
                  run_marker: work_id,
                  output_key,
                  created_utc,
                };

                execFileSync("bash", [
                  "phosphene/phosphene-core/bin/signal_bus.sh",
                  "append",
                  "--bus",
                  busPath,
                  "--line",
                  JSON.stringify(sig),
                ], { stdio: "inherit" });

                didAppend = true;
                commentLines.push("", `- emitted: \`${sig.signal_type}\``, `- signal_id: \`${signal_id}\``);
              } else {
                const retrigger_created_utc = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
                const retrigger_output_key = `${output_key}:retrigger:${retrigger_created_utc}`;
                const retrigger_hash_args = [
                  "phosphene/phosphene-core/bin/signal_hash.sh",
                  "signal-id",
                  "--run-marker",
                  work_id,
                  "--output-key",
                  retrigger_output_key,
                ];
                if (/^sha256:[0-9A-Fa-f]{64}$/.test(upstream_signal_id)) {
                  retrigger_hash_args.push("--parent", upstream_signal_id);
                }
                const retrigger_signal_id = String(execFileSync("bash", retrigger_hash_args, { encoding: "utf8" }) || "").trim();
                const retrigger_sig = {
                  signal_version: 1,
                  signal_id: retrigger_signal_id,
                  signal_type: `phosphene.autoscribe.${domain}.issue_created.v1`,
                  work_id,
                  domain,
                  issue_number,
                  lane: dm.lane,
                  intent,
                  phos_id: "",
                  parents: (/^sha256:[0-9A-Fa-f]{64}$/.test(upstream_signal_id) ? [upstream_signal_id] : []),
                  run_marker: work_id,
                  output_key: retrigger_output_key,
                  created_utc: retrigger_created_utc,
                  retrigger_of: signal_id,
                };
                execFileSync("bash", [
                  "phosphene/phosphene-core/bin/signal_bus.sh",
                  "append",
                  "--bus",
                  busPath,
                  "--line",
                  JSON.stringify(retrigger_sig),
                ], { stdio: "inherit" });
                didAppend = true;
                commentLines.push("", `- bus: already adopted; retrigger emitted`, `- signal_id: \`${retrigger_signal_id}\``);
              }
            }

            await github.rest.issues.createComment({ owner, repo, issue_number, body: commentLines.join("\n") });

            core.setOutput("did_append", didAppend ? "1" : "0");

      - name: Commit + push bus append (adopt mode)
        if: steps.tidy.outputs.did_append == '1'
        shell: bash
        run: |
          set -euo pipefail

          export PHOSPHENE_GANTRY_WRITE_ALLOWLIST=$'phosphene/signals/**\nphosphene/signals/indexes/**'
          bash phosphene/phosphene-core/bin/gantry_write_allowlist_guard.sh check

          if [[ -z "${PHOSPHENE_HUMAN_TOKEN:-}" ]]; then
            echo "PHOSPHENE: missing PHOSPHENE_HUMAN_TOKEN; refusing to push bus changes (would suppress downstream workflows)."
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${PHOSPHENE_HUMAN_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git add "phosphene/signals/bus.jsonl"
          git commit -m "PHOSPHENE: adopt issue #${{ inputs.issue_number }} into ${{ inputs.domain }} (autoscribe)" || exit 0
          git push origin HEAD:main

