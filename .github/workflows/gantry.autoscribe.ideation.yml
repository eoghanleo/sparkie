name: "gantry.autoscribe.ideation"

on:
  push:
    branches: [main]
    paths:
      - "phosphene/signals/bus.jsonl"
  workflow_dispatch:
    inputs:
      work_id:
        description: "Work ID (e.g., IDEA-0001)"
        required: false
        type: string
      lane:
        description: "Lane"
        required: false
        type: choice
        options: ["viridian"]
        default: "viridian"
      intent:
        description: "Intent string for the work"
        required: false
        type: string
        default: "idea-development"
      parent_signal_id:
        description: "Parent signal_id from bus.jsonl (optional)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: read
  issues: write

env:
  # Gantry write boundary (when/if enabled): signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**

concurrency:
  group: instrument-autoscribe-ideation-${{ github.sha || github.run_id }}
  cancel-in-progress: false

jobs:
  autoscribe_ideation_from_request_signals:
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v5
        with:
          ref: main
          fetch-depth: 0
          persist-credentials: false

      - name: Load done score config
        id: config
        shell: bash
        run: |
          set -euo pipefail
          done_score_min="$(bash phosphene/phosphene-core/bin/phosphene_config.sh get --color viridian --key ideation.done_score_min --default 10)"
          [[ -n "${done_score_min:-}" ]] || done_score_min="10"
          echo "done_score_min=$done_score_min" >> "$GITHUB_OUTPUT"
          echo "PHOSPHENE_DONE_SCORE_MIN=$done_score_min" >> "$GITHUB_ENV"

      - name: Extract newly added bus lines
        id: diff
        if: github.event_name == 'push'
        shell: bash
        run: |
          set -euo pipefail
          bus="phosphene/signals/bus.jsonl"
          before="${{ github.event.before }}"
          after="${{ github.sha }}"
          git diff --unified=0 "$before" "$after" -- "$bus" \
            | grep -E '^\+' \
            | grep -vE '^\+\+\+' \
            | sed -E 's/^\+//' \
            | grep -E '^\{' \
            > /tmp/new_lines.txt || true
          echo "count=$(wc -l < /tmp/new_lines.txt | tr -d ' ')" >> "$GITHUB_OUTPUT"

      - name: Validate signal bus tamper hash (JSONL)
        if: github.event_name != 'push' || steps.diff.outputs.count != '0'
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "push" ]]; then
            fail=0
            while IFS= read -r line; do
              [[ -n "${line:-}" ]] || continue
              bash phosphene/phosphene-core/bin/signal_tamper_hash.sh validate-line "$line" >/dev/null 2>&1 || fail=1
            done < /tmp/new_lines.txt
            [[ "$fail" -eq 0 ]]
          else
            bash phosphene/phosphene-core/bin/signal_bus.sh validate --bus phosphene/signals/bus.jsonl
          fi

      - name: Create ideation issue(s) from request signal(s)
        id: autoscribe
        uses: actions/github-script@v7
        env:
          PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}
        with:
          script: |
            const fs = require("fs");
            const crypto = require("crypto");
            const { execFileSync } = require("child_process");
            const { owner, repo } = context.repo;

            const humanToken = String(process.env.PHOSPHENE_HUMAN_TOKEN || "").trim();
            const apiBase = String(process.env.GITHUB_API_URL || "https://api.github.com").replace(/\/+$/, "");
            const apiHeaders = (token) => ({
              accept: "application/vnd.github+json",
              "content-type": "application/json",
              authorization: `token ${token}`,
              "x-github-api-version": "2022-11-28",
            });
            const apiJson = async (path, { method, token, body }) => {
              const resp = await fetch(`${apiBase}${path}`, {
                method,
                headers: apiHeaders(token),
                body: body ? JSON.stringify(body) : undefined,
              });
              const text = await resp.text();
              if (!resp.ok) throw new Error(`GitHub API ${method} ${path} failed: ${resp.status} ${resp.statusText} :: ${text}`);
              return text ? JSON.parse(text) : null;
            };

            const createIssue = async ({ title, body, labels }) => {
              if (humanToken) {
                return await apiJson(`/repos/${owner}/${repo}/issues`, { method: "POST", token: humanToken, body: { title, body, labels } });
              }
              const resp = await github.rest.issues.create({ owner, repo, title, body, labels });
              return resp.data;
            };

            const busPath = "phosphene/signals/bus.jsonl";
            const templatePath = ".github/prompts/domain_delegation_prompt.md";
            if (!fs.existsSync(templatePath)) throw new Error(`Missing template file: ${templatePath}`);
            const template = fs.readFileSync(templatePath, "utf8");

            const busHasIssueCreatedForParent = (parent_signal_id) => {
              if (!parent_signal_id || !fs.existsSync(busPath)) return false;
              const lines = fs.readFileSync(busPath, "utf8").split(/\r?\n/).map(l => l.trim()).filter(Boolean);
              for (let i = lines.length - 1; i >= 0; i--) {
                try {
                  const j = JSON.parse(lines[i]);
                  if (j?.signal_type !== "phosphene.autoscribe.ideation.issue_created.v1") continue;
                  const parents = Array.isArray(j.parents) ? j.parents : [];
                  if (parents.includes(parent_signal_id)) return true;
                } catch {}
              }
              return false;
            };

            const parseRequestSignal = (signalType) => {
              const m = String(signalType || "").match(/^phosphene\.request\.([^.]+)\.([^.]+)\.([^.]+)\.v1$/);
              if (!m) return null;
              return { requestingDomain: m[1], targetDomain: m[2], workType: m[3] };
            };

            const createIssueAndEmit = async ({ work_id, lane, intent, parent_signal_id, upstream_domain, pointers, upstream_work_id }) => {
              const resolvedWorkId = String(work_id || "").trim();
              const resolvedParentSignalId = String(parent_signal_id || "").trim();
              const resolvedLane = String(lane || "viridian").trim().toLowerCase();
              const resolvedIntent = String(intent || "idea-development").trim();
              const resolvedUpstreamDomain = String(upstream_domain || "unknown").trim() || "unknown";
              const resolvedUpstreamWorkId = String(upstream_work_id || "").trim() || resolvedWorkId;

              if (!resolvedWorkId) return null;

              if (resolvedParentSignalId && busHasIssueCreatedForParent(resolvedParentSignalId)) {
                core.notice(`PHOSPHENE: autoscribe already emitted issue_created for parent_signal_id=${resolvedParentSignalId} (skip).`);
                return null;
              }

              const dedupeMarker = resolvedParentSignalId
                ? `phosphene-signal-id:${resolvedParentSignalId}`
                : `phosphene-autoscribe:ideation:work_id:${resolvedWorkId}`;

              const search = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} "${dedupeMarker}" in:body type:issue`,
                per_page: 5,
              });
              if (search.data.items.length > 0) {
                core.notice(`PHOSPHENE: issue already exists for ${resolvedWorkId} (dedupe hit).`);
                return null;
              }

              const domainTag = "<ideation>";
              const upstreamDomainTag = `<${resolvedUpstreamDomain}>`;
              const domainSkillPath = ".codex/skills/phosphene/viridian/ideation/modulator/SKILL.md";
              const domainScriptsPath = ".codex/skills/phosphene/viridian/ideation/modulator/scripts/";
              const doneScoreMin = String(process.env.PHOSPHENE_DONE_SCORE_MIN || "10").trim();
              const domainDoneScoreCmd = `./.github/scripts/ideation-domain-done-score.sh --file <IDEA_PATH> --min-score ${doneScoreMin}`;
              const manifoldProbeCountRaw = String(process.env.PHOSPHENE_MANIFOLD_PROBE_COUNT || "10").trim();
              const manifoldProbeCount = Math.max(2, Number.parseInt(manifoldProbeCountRaw, 10) || 10);

              const pointerLines = Array.isArray(pointers) && pointers.length
                ? pointers
                : [`- Upstream signal: ${resolvedParentSignalId || "(none)"}`];

              const seedInputValues = [
                resolvedLane,
                "ideation",
                resolvedWorkId,
                resolvedIntent,
                "",
                "",
                resolvedParentSignalId || "",
                String(manifoldProbeCount),
              ].join("\n");
              const seedSha256 = `${crypto.createHash("sha256").update(seedInputValues).digest("hex")}`;

              const notesBlock = [
                "## STORM TABLE (mandatory for this run)",
                "",
                "### Intended behavior",
                "- Produce a single IDEA artifact that contains a **Storm table** aligned to the primary objective:",
                `  - Select ${manifoldProbeCount} probes from \`WIP/creative_madness/manifold_probes.jsonl\` using seed_sha256 from the PHOSPHENE block.`,
                "  - Create rows for every unordered probe pair × 3 rings (adjacent/orthogonal/extrapolatory).",
                "  - Columns: STORM-ID, PROBE_1, PROBE_2, RING, DESCRIPTION.",
                "  - DESCRIPTION must be a paragraph (≥ 3 sentences) influenced by PROBE_1 + PROBE_2 + RING; every description must be within the frame and exploring the creative space of the primary objective.",
                "- Use bash scripts to update the storm table (do not hand-edit table rows).",
                "- Use the SPARK snapshot as the authoritative primary input; treat the primary objective as the anchor for scope.",
                "- Output volume is evaluated against the primary input only: gate at 3x, full points at 10x.",
                "- Secondary inputs (from [PHOSPHENE_INPUTS]) do NOT increase the volume requirement.",
                "- If secondary inputs are present, cite IDs from within those bundles (not just the top-level ID).",
                "",
                "### Interpreting success",
                "- Success means: storm table is complete, descriptions are real (≥3 sentences), and probe pairs are treated as divergence drivers.",
                "- Validators will fail if: SPARK missing, SeedSHA256 missing, wrong row count, missing/placeholder cells, or any DESCRIPTION <3 sentences.",
                "- Done-score will fail if output volume is below 3x primary input.",
                "",
                "### Input notes",
                "- Hopper will create a SPARK snapshot from this issue after eligibility.",
                "- SPARK path: `phosphene/signals/sparks/SPARK-<issue_number>.md` (issue-number derived)",
                "- Optional: include extra repo inputs using the block below.",
                "",
                "[PHOSPHENE_INPUTS]",
                "- RA-001",
                "- VPD-002",
                "[/PHOSPHENE_INPUTS]",
                "",
              ].join(\"\\n\");

              const phospheneBlock = [
                "[PHOSPHENE]",
                `lane: ${resolvedLane}`,
                "work_type: ideation",
                `work_id: ${resolvedWorkId}`,
                `intent: ${resolvedIntent}`,
                "depends_on:",
                "sequence:",
                `upstream_signal_id: ${resolvedParentSignalId || ""}`.trimEnd(),
                `manifold_probe_count: ${manifoldProbeCount}`,
                `seed_sha256: ${seedSha256}`,
                "[/PHOSPHENE]",
              ].join("\n");

              const issueTitle = `PHOSPHENE: <ideation> Idea development for ${resolvedWorkId}`;
              const body = [
                phospheneBlock,
                "",
                template
                  .replaceAll("{{UPSTREAM_PR_NUMBER}}", "N/A")
                  .replaceAll("{{UPSTREAM_PR_TITLE}}", "(request-signal triggered; no PR context)")
                  .replaceAll("{{UPSTREAM_PR_URL}}", "(n/a)")
                  .replaceAll("{{UPSTREAM_WORK_ID}}", resolvedUpstreamWorkId || "(unknown)")
                  .replaceAll("{{SIGNAL_PATH}}", resolvedParentSignalId ? `phosphene/signals/bus.jsonl#${resolvedParentSignalId}` : "phosphene/signals/bus.jsonl")
                  .replaceAll("{{UPSTREAM_DOMAIN_TAG}}", upstreamDomainTag)
                  .replaceAll("{{DOMAIN_TAG}}", domainTag)
                  .replaceAll("{{DOMAIN_SKILL_PATH}}", domainSkillPath)
                  .replaceAll("{{DOMAIN_SCRIPTS_PATH}}", domainScriptsPath)
                  .replaceAll("{{DOMAIN_DONE_SIGNAL_PATH}}", "phosphene/signals/bus.jsonl (DONE receipt line)")
                  .replaceAll("{{DONE_SCORE_MIN}}", doneScoreMin)
                  .replaceAll("{{DOMAIN_DONE_SCORE_CMD}}", domainDoneScoreCmd)
                  .replaceAll("{{INTENT}}", resolvedIntent)
                  .replaceAll("{{POINTERS_BULLETS}}", pointerLines.join("\n"))
                  .replaceAll("{{NOTES_BLOCK}}", notesBlock)
                  .replaceAll("{{PHOSPHENE_DEDUPE_MARKER}}", dedupeMarker),
              ].join("\n");

              const labels = [
                "phosphene",
                `phosphene:${resolvedLane}`,
                "phosphene:domain:ideation",
                "phosphene:instrument:autoscribe",
                "phosphene:ready",
              ];

              const issue = await createIssue({ title: issueTitle, body, labels });
              core.notice(`PHOSPHENE: created ideation issue #${issue.number}: ${issue.html_url}`);

              const created_utc = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
              const output_key = `autoscribe:issue-created:ideation:issue:${issue.number}`;
              const hashArgs = [
                "phosphene/phosphene-core/bin/signal_hash.sh",
                "signal-id",
                "--run-marker",
                resolvedWorkId,
                "--output-key",
                output_key,
              ];
              if (resolvedParentSignalId) hashArgs.push("--parent", resolvedParentSignalId);
              const signal_id = String(execFileSync("bash", hashArgs, { encoding: "utf8" })).trim();

              const sig = {
                signal_version: 1,
                signal_id,
                signal_type: "phosphene.autoscribe.ideation.issue_created.v1",
                work_id: resolvedWorkId,
                domain: "ideation",
                issue_number: issue.number,
                lane: resolvedLane,
                intent: resolvedIntent,
                phos_id: "",
                parents: resolvedParentSignalId ? [resolvedParentSignalId] : [],
                run_marker: resolvedWorkId,
                output_key,
                created_utc,
              };

              execFileSync("bash", [
                "phosphene/phosphene-core/bin/signal_bus.sh",
                "append",
                "--bus",
                busPath,
                "--line",
                JSON.stringify(sig),
              ], { stdio: "inherit" });

              return { issue_number: issue.number, work_id: resolvedWorkId, signal_id };
            };

            const created = [];
            if (context.eventName === "workflow_dispatch") {
              const workIdInput = String(core.getInput("work_id") || "").trim();
              const laneInput = String(core.getInput("lane") || "").trim().toLowerCase();
              const intentInput = String(core.getInput("intent") || "").trim();
              const parentSignalId = String(core.getInput("parent_signal_id") || "").trim();
              const out = await createIssueAndEmit({
                work_id: workIdInput,
                lane: laneInput || "viridian",
                intent: intentInput || "idea-development",
                parent_signal_id: parentSignalId,
              });
              if (out) created.push(out);
            } else if (context.eventName === "push") {
              const raw = fs.existsSync("/tmp/new_lines.txt") ? fs.readFileSync("/tmp/new_lines.txt", "utf8") : "";
              const lines = raw.split(/\n/).filter(Boolean);
              for (const line of lines) {
                let j;
                try { j = JSON.parse(line); } catch { continue; }
                const req = parseRequestSignal(j.signal_type);
                if (!req || req.targetDomain !== "ideation") continue;
                const requesting_work_id = String(j.work_id || "").trim();
                const requested_work_id = String(j.requested_work_id || "").trim();
                const work_id = requested_work_id || requesting_work_id;
                if (!work_id) continue;
                const parent_signal_id = String(j.signal_id || "").trim();
                const upstream_domain = String(j.domain || req.requestingDomain || "").trim();
                const issue_number = Number(j.issue_number || 0);
                const intent = req.workType ? req.workType : "idea-development";
                const pointers = [
                  upstream_domain ? `- Requesting domain: <${upstream_domain}>` : "- Requesting domain: (unknown)",
                  issue_number ? `- Requesting issue: #${issue_number}` : "- Requesting issue: (n/a)",
                  requesting_work_id ? `- Requesting work_id: \`${requesting_work_id}\`` : "- Requesting work_id: (n/a)",
                  `- Requested work_id: \`${work_id}\``,
                ];
                const out = await createIssueAndEmit({
                  work_id,
                  lane: "viridian",
                  intent,
                  parent_signal_id,
                  upstream_domain,
                  pointers,
                  upstream_work_id: requesting_work_id || work_id,
                });
                if (out) created.push(out);
              }
            }

            if (created.length === 0) {
              core.notice("PHOSPHENE: no autoscribe work performed (no matching signals or all deduped).");
              return;
            }

            core.setOutput("did_append", "1");
            core.setOutput("issues", created.map((c) => String(c.issue_number)).join(","));
            core.notice(`PHOSPHENE: autoscribed issues: ${created.map((c) => `#${c.issue_number}`).join(", ")}`);

      - name: Commit + push bus append
        if: steps.autoscribe.outputs.did_append == '1'
        shell: bash
        env:
          PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}
        run: |
          set -euo pipefail

          export PHOSPHENE_GANTRY_WRITE_ALLOWLIST=$'phosphene/signals/**\nphosphene/signals/indexes/**'
          bash phosphene/phosphene-core/bin/gantry_write_allowlist_guard.sh check

          if [[ -z "${PHOSPHENE_HUMAN_TOKEN:-}" ]]; then
            echo "PHOSPHENE: missing PHOSPHENE_HUMAN_TOKEN; refusing to push bus changes (would suppress downstream workflows)."
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${PHOSPHENE_HUMAN_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

          # If bus wasn't modified (shouldn't happen), exit gracefully.
          if git diff --quiet -- "phosphene/signals/bus.jsonl"; then
            echo "PHOSPHENE: bus.jsonl unchanged; nothing to commit."
            exit 0
          fi

          git add "phosphene/signals/bus.jsonl"
          git commit -m "PHOSPHENE: autoscribe ideation issue_created for issue(s) ${{ steps.autoscribe.outputs.issues }}"
          git push origin HEAD:main
