name: "gantry.detector.global"

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      action:
        description: "Which detector action to run"
        required: true
        type: choice
        options: ["runtime_predicates", "file_authorization", "beam_safety", "apparatus_log_attach"]
        default: "runtime_predicates"
      title:
        description: "Title for the runtime detector run (runtime_predicates only)"
        required: false
        type: string
        default: "Runtime detector predicates"
      command:
        description: "Deterministic predicate command to run (bash) (runtime_predicates only)"
        required: false
        type: string
        default: ""
      pr_number:
        description: "Optional PR number to annotate / drive follow-on actions (runtime_predicates only)"
        required: false
        type: number
      on_success_authorize:
        description: "If true (and pr_number set), post condenser authorization note"
        required: false
        type: boolean
        default: false
      on_failure_rework_lane:
        description: "If set (and pr_number set), post a /phosphene summon comment to trigger rework"
        required: false
        type: choice
        options:
          - ""
          - beryl
          - cerulean
        default: ""
      on_failure_rework_intent:
        description: "Intent string passed to /phosphene <lane> <intent>"
        required: false
        type: string
        default: "rework: detector predicates failed"

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  # Gantry write boundary (when/if enabled): signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**

jobs:
  signals_integrity:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Enforce append-only bus changes (PR)
        shell: bash
        run: |
          set -euo pipefail

          bus="phosphene/signals/bus.jsonl"

          # Only enforce when bus.jsonl is touched in this PR.
          if ! git diff --name-only "origin/${{ github.base_ref }}"..."${{ github.sha }}" -- | grep -qx "$bus"; then
            exit 0
          fi

          # Ensure base ref exists locally for diffing.
          git fetch origin "${{ github.base_ref }}:refs/remotes/origin/${{ github.base_ref }}" --force

          # Reject any deletions/modifications (only allow '+' additions).
          if git diff "origin/${{ github.base_ref }}"..."${{ github.sha }}" -- "$bus" | grep -qE '^-[^-]'; then
            echo "FAIL: $bus must be append-only (no deletions/modifications)." >&2
            exit 1
          fi

      - name: Validate signal bus JSONL (parse + required fields + tamper_hash)
        shell: bash
        run: |
          set -euo pipefail

          bus="phosphene/signals/bus.jsonl"
          if [[ ! -f "$bus" ]]; then
            echo "Missing signal bus: $bus" >&2
            exit 1
          fi

          fail=0
          line_num=0
          while IFS= read -r line || [[ -n "${line:-}" ]]; do
            line_num=$((line_num + 1))
            [[ -n "${line:-}" ]] || continue

            if ! node -e '
              const line = process.argv[1];
              const lineNo = process.argv[2];
              let j;
              try { j = JSON.parse(line); }
              catch { console.error(`FAIL: invalid JSON (line ${lineNo})`); process.exit(1); }

              if (typeof j !== "object" || j === null || Array.isArray(j)) {
                console.error(`FAIL: signal must be a JSON object (line ${lineNo})`);
                process.exit(1);
              }
              if (!("signal_version" in j) || j.signal_version !== 1) {
                console.error(`FAIL: signal_version must be 1 (line ${lineNo})`);
                process.exit(1);
              }
              if (!("signal_type" in j) || typeof j.signal_type !== "string" || j.signal_type.trim() === "") {
                console.error(`FAIL: signal_type must be a non-empty string (line ${lineNo})`);
                process.exit(1);
              }
              if (!("tamper_hash" in j) || typeof j.tamper_hash !== "string" || !/^sha256:[0-9a-f]{64}$/i.test(j.tamper_hash)) {
                console.error(`FAIL: tamper_hash must be \"sha256:<64-hex>\" (line ${lineNo})`);
                process.exit(1);
              }
            ' "$line" "$line_num"; then
              fail=1
              continue
            fi

            if ! bash phosphene/phosphene-core/bin/signal_tamper_hash.sh validate-line "$line" >/dev/null 2>&1; then
              echo "FAIL: tamper_hash mismatch (line $line_num): $bus" >&2
              fail=1
            fi
          done < "$bus"

          [[ "$fail" -eq 0 ]]

      - name: Summary
        if: always()
        run: |
          {
            echo "### Signals integrity"
            echo ""
            echo "- **Result**: ${{ job.status }}"
            echo "- **Scope**: \`phosphene/signals/bus.jsonl\`"
          } >> "$GITHUB_STEP_SUMMARY"

  predicates:
    if: github.event_name == 'workflow_dispatch' && inputs.action == 'runtime_predicates'
    name: ${{ inputs.title }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Validate inputs (runtime_predicates)
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${{ inputs.command }}" ]]; then
            echo "Missing required input: command (for action=runtime_predicates)" >&2
            exit 2
          fi

      - name: Run predicate command
        shell: bash
        run: ${{ inputs.command }}

  on_success_authorize:
    if: needs.predicates.result == 'success' && inputs.on_success_authorize && inputs.pr_number
    needs: [predicates]
    runs-on: ubuntu-latest
    steps:
      - name: Post condenser authorization note (comment only)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = Number("${{ inputs.pr_number }}");
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pr_number,
              body: [
                "PHOSPHENE: condenser authorization",
                "",
                "- **Message**: Detector runtime predicates are green.",
              ].join("\\n"),
            });

  on_failure_rework:
    if: needs.predicates.result != 'success' && inputs.on_failure_rework_lane != '' && inputs.pr_number
    needs: [predicates]
    runs-on: ubuntu-latest
    steps:
      - name: Post PHOSPHENE rework summon (multiline; first line is the command)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr_number = Number("${{ inputs.pr_number }}");
            const lane = ("${{ inputs.on_failure_rework_lane }}" || "").trim();
            const intent = ("${{ inputs.on_failure_rework_intent }}" || "").trim() || "rework: detector predicates failed";
            const cmd = `\/phosphene ${lane} ${intent}`.trim();

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pr_number,
              body: [
                cmd,
                "",
                "PHOSPHENE: this summon was emitted by a DETECTOR after predicate failure.",
                "",
                `- **Detector**: \`${context.workflow}\``,
                `- **Run**: \`${context.runId}\``,
                `- **Predicate command**: \`${{ inputs.command }}\``,
              ].join("\n"),
            });

  file_authorization:
    if: github.event_name == 'workflow_dispatch' && inputs.action == 'file_authorization'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "TODO: implement Planning authorized file list signal + diff scan + TRAP ruling."

  beam_safety:
    if: github.event_name == 'workflow_dispatch' && inputs.action == 'beam_safety'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "TODO: define the beam safety corridor (schema lint, policy checks, budget checks)."

  apparatus_log_attach:
    if: github.event_name == 'workflow_dispatch' && inputs.action == 'apparatus_log_attach'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "TODO: attach apparatus log artifact to PR as summary/comment."

