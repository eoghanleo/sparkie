name: "gantry.autoscribe.global"

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Which autoscribe action to run"
        required: true
        type: choice
        options: ["flimsie", "enforce_issue_block"]
        default: "flimsie"
      title:
        description: "New flimsie (issue) title"
        required: false
        type: string
        default: ""
      body:
        description: "New flimsie (issue) body (markdown)"
        required: false
        type: string
        default: ""
      labels:
        description: "Comma-separated labels (optional)"
        required: false
        type: string
        default: "phosphene,phosphene:flimsie"
      assignees:
        description: "Comma-separated assignees (optional; usernames)"
        required: false
        type: string
        default: ""
      dedupe_marker:
        description: "If set, skip creation when an existing issue body contains this exact marker"
        required: false
        type: string
        default: ""
      summon_codex:
        description: "If true, post '@codex take issue.' as a comment on the new issue"
        required: false
        type: boolean
        default: false
      issue_number:
        description: "Issue number to normalize (enforce_issue_block only)"
        required: false
        type: number
      mode:
        description: "enforce_issue_block: normalize or report"
        required: false
        type: choice
        options: ["normalize", "report"]
        default: "normalize"

permissions:
  # CRITICAL: autoscribe may create issues, but MUST NOT be able to write repo contents.
  issues: write
  contents: read

env:
  # Gantry write boundary (when/if enabled): signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**

concurrency:
  group: instrument-autoscribe-global-${{ github.event.inputs.issue_number || github.run_id }}
  cancel-in-progress: true

jobs:
  create_flimsie:
    if: github.event_name != 'workflow_dispatch' || inputs.action == 'flimsie'
    runs-on: ubuntu-latest
    steps:
      - name: Create flimsie (issue)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            const splitCsv = (s) =>
              (s || "")
                .split(",")
                .map((x) => x.trim())
                .filter(Boolean);

            const dedupeIfNeeded = async (dedupeMarker) => {
              const marker = (dedupeMarker || "").trim();
              if (!marker) return false;

              const search = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} "${marker}" in:body type:issue`,
                per_page: 5,
              });
              return search.data.items.length > 0;
            };

            const postUsage = async (issue_number) => {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: [
                  "PHOSPHENE: autoscribe usage:",
                  "",
                  "- Create a new flimsie: `/flimsie <title>`",
                  "- Or: `/phosphene flimsie <title>`",
                  "",
                  "Tip: Put any additional details on subsequent lines; they will be copied into the new issue body.",
                ].join("\n"),
              });
            };

            let title = "";
            let body = "";
            let labels = [];
            let assignees = [];
            let dedupe_marker = "";
            let summon_codex = false;
            let sourceIssueNumber = null;
            let sourceUrl = "";

            if (context.eventName === "workflow_dispatch") {
              if ((core.getInput("action", { required: true }) || "").trim() !== "flimsie") return;

              title = String(core.getInput("title") || "").trim();
              if (!title) {
                core.setFailed("Missing required input: title (for action=flimsie)");
                return;
              }
              body = String(core.getInput("body") || "");
              labels = splitCsv(core.getInput("labels"));
              assignees = splitCsv(core.getInput("assignees"));
              dedupe_marker = String(core.getInput("dedupe_marker") || "").trim();
              summon_codex = String(core.getInput("summon_codex") || "false").toLowerCase() === "true";
            } else {
              core.notice(`PHOSPHENE: unsupported event ${context.eventName}; no-op.`);
              return;
            }

            if (await dedupeIfNeeded(dedupe_marker)) {
              core.notice(`PHOSPHENE: dedupe hit; not creating issue (marker: ${dedupe_marker}).`);
              if (sourceIssueNumber) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: sourceIssueNumber,
                  body: `PHOSPHENE: autoscribe dedupe hit; a flimsie already exists for marker \`${dedupe_marker}\`.`,
                });
              }
              return;
            }

            // Normalize body: ensure marker is included if provided.
            const markerBlock = dedupe_marker ? `\n\n${dedupe_marker}\n` : "";
            // Default autoscribe behavior: mark new issues as INFORMAL unless/until
            // a stricter autoscribe/enforcer upgrades them to a FORMAL config.
            const phospheneBlock = ["[PHOSPHENE]", "INFORMAL", "[/PHOSPHENE]"].join("\n");

            const issueBody = `${phospheneBlock}\n\n${body || ""}${markerBlock}`.trim() + "\n";

            const issue = await github.rest.issues.create({
              owner,
              repo,
              title,
              body: issueBody,
              labels: labels.length ? labels : undefined,
              assignees: assignees.length ? assignees : undefined,
            });

            core.notice(`PHOSPHENE: created flimsie #${issue.data.number}: ${issue.data.html_url}`);

            if (sourceIssueNumber) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: sourceIssueNumber,
                body: `PHOSPHENE: autoscribed flimsie created: #${issue.data.number} (${issue.data.html_url})`,
              });
            }

            if (summon_codex) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issue.data.number,
                body: [
                  "@codex take issue.",
                  "",
                  "PHOSPHENE: autoscribe requested Codex pickup for this flimsie.",
                ].join("\n"),
              });
            }

  enforce_issue_block:
    if: github.event_name != 'workflow_dispatch' || inputs.action == 'enforce_issue_block'
    runs-on: ubuntu-latest
    steps:
      - name: Enforce [PHOSPHENE] block (normalize/report)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            const isBotUser = (u) => {
              const login = (u?.login || "").toLowerCase();
              return Boolean(u?.type === "Bot" || login.endsWith("[bot]") || login === "github-actions");
            };

            const PH_OPEN = "[PHOSPHENE]";
            const PH_CLOSE = "[/PHOSPHENE]";

            const isInformalBlock = (raw) => {
              return /(^|\n)\s*informal\s*(\n|$)/i.test(String(raw || ""));
            };

            const canonicalBlock = (kv) => {
              // Default autoscribe behavior: if we cannot confidently form a "formal" block,
              // mark as INFORMAL. Hopper treats INFORMAL as valid-but-noop (prevents loops).
              if (kv.informal) {
                return [PH_OPEN, "INFORMAL", PH_CLOSE].join("\n");
              }

              const required = ["lane", "work_type", "work_id", "intent"];
              if (required.some((k) => !String(kv[k] || "").trim())) {
                return [PH_OPEN, "INFORMAL", PH_CLOSE].join("\n");
              }

              const lines = [
                PH_OPEN,
                `lane: ${kv.lane || ""}`.trimEnd(),
                `work_type: ${kv.work_type || ""}`.trimEnd(),
                `work_id: ${kv.work_id || ""}`.trimEnd(),
                `intent: ${kv.intent || ""}`.trimEnd(),
                `depends_on: ${kv.depends_on || ""}`.trimEnd(),
                `sequence: ${kv.sequence || ""}`.trimEnd(),
                `upstream_signal_id: ${kv.upstream_signal_id || ""}`.trimEnd(),
                PH_CLOSE,
              ];
              return lines.join("\n");
            };

            const extractBlock = (text) => {
              const openIdx = text.indexOf(PH_OPEN);
              if (openIdx === -1) return null;
              const closeIdx = text.indexOf(PH_CLOSE, openIdx);
              const endIdx = closeIdx === -1 ? text.length : closeIdx + PH_CLOSE.length;
              return {
                openIdx,
                endIdx,
                raw: text.slice(openIdx, endIdx),
              };
            };

            const parseKvFromBlock = (rawBlock) => {
              const kv = {};
              const lines = rawBlock.split(/\r?\n/);
              for (const line of lines) {
                if (!line.includes(":")) continue;
                if (line.trim() === PH_OPEN || line.trim() === PH_CLOSE) continue;
                const m = line.match(/^\s*([a-zA-Z_]+)\s*:\s*(.*?)\s*$/);
                if (!m) continue;
                const key = m[1].toLowerCase();
                const val = m[2].trim();
                kv[key] = val;
              }
              return kv;
            };

            const laneFromLabels = (labels) => {
              const set = new Set((labels || []).map((s) => String(s).toLowerCase()));
              if (set.has("phosphene:amaranth")) return "amaranth";
              if (set.has("phosphene:beryl")) return "beryl";
              if (set.has("phosphene:cadmium")) return "cadmium";
              if (set.has("phosphene:cerulean")) return "cerulean";
              if (set.has("phosphene:viridian")) return "viridian";
              return "";
            };

            const dependsFromBodyLoose = (body) => {
              // Optional helper: preserve an existing "depends_on:" line outside the block.
              const m = body.match(/^\s*(depends-on|depends_on)\s*:\s*(.+?)\s*$/im);
              return m ? m[2].trim() : "";
            };

            // --- Determine invocation
            let issue_number = null;
            let mode = "normalize";

            if (context.eventName === "workflow_dispatch") {
              if ((core.getInput("action", { required: true }) || "").trim() !== "enforce_issue_block") return;

              const nRaw = String(core.getInput("issue_number") || "").trim();
              issue_number = nRaw ? Number(nRaw) : null;
              mode = (core.getInput("mode") || "normalize").trim().toLowerCase();
              if (!issue_number) {
                core.setFailed("Missing required input: issue_number (for action=enforce_issue_block)");
                return;
              }
            } else {
              return;
            }

            if (!issue_number) return;

            // --- Load issue
            const issueResp = await github.rest.issues.get({ owner, repo, issue_number });
            const issue = issueResp.data;
            const title = String(issue.title || "").trim();
            const body = String(issue.body || "");
            const labels = (issue.labels || [])
              .map((l) => (typeof l === "string" ? l : l?.name))
              .filter(Boolean)
              .map((s) => String(s));

            const existing = extractBlock(body);
            const existingKv = existing ? parseKvFromBlock(existing.raw) : {};
            const existingIsInformal = existing ? isInformalBlock(existing.raw) : false;

            const desired = {
              lane: existingKv.lane || laneFromLabels(labels) || "",
              work_type: existingKv.work_type || "",
              intent: existingKv.intent || title || "",
              depends_on: existingKv.depends_on || dependsFromBodyLoose(body) || "",
              sequence: existingKv.sequence || "",
            };

            // Decide whether we can emit a formal block.
            // Minimal bar for "formal":
            // - lane is beryl|cerulean
            // - work_type is present (non-empty)
            const laneOk = ["beryl", "cerulean"].includes(String(desired.lane || "").toLowerCase());
            const workTypeOk = Boolean(String(desired.work_type || "").trim());
            const informal = existingIsInformal || !(laneOk && workTypeOk);

            const newBlock = canonicalBlock({ ...desired, informal });

            const report = [
              "PHOSPHENE AUTOSCRIBE: enforce [PHOSPHENE] block",
              "",
              `- **Issue**: #${issue_number}`,
              `- **Mode**: \`${mode}\``,
              `- **Existing block**: ${existing ? "YES" : "NO"}`,
              `- **Block classification**: ${informal ? "`INFORMAL`" : "`FORMAL`"}`,
              `- **Lane**: ${desired.lane ? "`" + desired.lane + "`" : "(missing)"}`,
              `- **Work type**: ${desired.work_type ? "`" + desired.work_type + "`" : "(missing)"}`,
              `- **Intent**: ${desired.intent ? desired.intent : "(missing)"}`,
              `- **Depends_on**: ${desired.depends_on ? desired.depends_on : "(none)"}`,
              `- **Sequence**: ${desired.sequence ? desired.sequence : "(none)"}`,
              "",
              "Block preview:",
              "```text",
              newBlock,
              "```",
            ].join("\n");

            if (mode === "report") {
              await github.rest.issues.createComment({ owner, repo, issue_number, body: report });
              return;
            }

            // --- Apply normalization (update issue body)
            let updatedBody = body;
            if (existing) {
              updatedBody = body.slice(0, existing.openIdx) + newBlock + body.slice(existing.endIdx);
            } else {
              // Prepend block for maximum visibility.
              updatedBody = `${newBlock}\n\n${body}`.trimEnd() + "\n";
            }

            if (updatedBody !== body) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number,
                body: updatedBody,
              });
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: report,
            });
