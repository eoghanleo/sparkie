name: "gantry.hopper.product-strategy"

on:
  push:
    branches: [main]
    paths:
      - "phosphene/signals/bus.jsonl"
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to evaluate"
        required: false
        type: number

permissions:
  contents: write
  issues: write

env:
  # Gantry write boundary: signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**
  PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}

concurrency:
  group: instrument-hopper-product-strategy-${{ inputs.issue_number || github.sha || github.run_id }}
  cancel-in-progress: true

jobs:
  interpret:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v5
        with:
          ref: main
          fetch-depth: 0
          persist-credentials: false

      - name: Decide + append start signal (if eligible)
        id: decide
        uses: actions/github-script@v7
        with:
          script: |
            const { execFileSync } = require("child_process");
            const fs = require("fs");
            const { owner, repo } = context.repo;
            const busPath = "phosphene/signals/bus.jsonl";
            const addedLines = [];

            if (context.eventName === "push") {
              const before = String(context.payload.before || "").trim();
              const after = String(context.sha || "").trim();
              if (!before || !after) return;
              const cmd = [
                "bash",
                "-lc",
                [
                  `bus="${busPath}"`,
                  `git diff --unified=0 "${before}" "${after}" -- "${busPath}" \\`,
                  `  | grep -E '^\\+' \\`,
                  `  | grep -vE '^\\+\\+\\+' \\`,
                  `  | sed -E 's/^\\+//' \\`,
                  `  | grep -E '^\\{' || true`,
                ].join("\n"),
              ];
              const out = String(execFileSync(cmd[0], cmd.slice(1), { encoding: "utf8" }) || "");
              for (const line of out.split(/\r?\n/)) {
                const t = line.trim();
                if (t) addedLines.push(t);
              }
            } else if (context.eventName === "workflow_dispatch") {
              // Manual: evaluate a specific issue (no bus trigger required).
              const raw = String(core.getInput("issue_number") || "").trim();
              if (!raw) {
                core.notice("PHOSPHENE: workflow_dispatch requires issue_number for hopper manual evaluation.");
                return;
              }
              const issue_number = Number(raw);
              addedLines.push(JSON.stringify({
                signal_type: "phosphene.autoscribe.product-strategy.issue_created.v1",
                issue_number,
                signal_id: "",
              }));
            } else {
              return;
            }

            const MARKER_STARTED = "PHOSPHENE-HOPPER-PRODUCT-STRATEGY:START-SIGNAL-EMITTED";
            const MARKER_REPORT = "PHOSPHENE-HOPPER-PRODUCT-STRATEGY:REPORT";

            const PH_OPEN = "[PHOSPHENE]";
            const PH_CLOSE = "[/PHOSPHENE]";
            const extractBlock = (text) => {
              const openIdx = text.indexOf(PH_OPEN);
              if (openIdx === -1) return null;
              const closeIdx = text.indexOf(PH_CLOSE, openIdx);
              if (closeIdx === -1) return null;
              return text.slice(openIdx, closeIdx + PH_CLOSE.length);
            };
            const REQUIRED_KEYS = [
              "lane",
              "work_type",
              "work_id",
              "intent",
              "depends_on",
              "sequence",
              "upstream_signal_id",
            ];

            const parseStrictBlock = (rawBlock) => {
              const kv = {};
              const errors = [];
              const lines = rawBlock.split(/\r?\n/).slice(1, -1);

              if (lines.length !== REQUIRED_KEYS.length) {
                errors.push(`expected ${REQUIRED_KEYS.length} lines, found ${lines.length}`);
              }

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const m = line.match(/^\s*([a-zA-Z_]+)\s*:\s*(.*?)\s*$/);
                if (!m) {
                  errors.push(`line ${i + 1} is not key:value`);
                  continue;
                }
                const key = m[1].toLowerCase();
                const value = String(m[2] || "").trim();
                const expected = REQUIRED_KEYS[i];
                if (key !== expected) {
                  errors.push(`line ${i + 1} expected key "${expected}", got "${key}"`);
                  continue;
                }
                if (["lane", "work_type", "work_id", "intent"].includes(key) && !value) {
                  errors.push(`"${key}" must be non-empty`);
                }
                kv[key] = value;
              }

              return { kv, errors };
            };
            const isInformalBlock = (rawBlock) => /(^|\n)\s*informal\s*(\n|$)/i.test(String(rawBlock || ""));

            const busLines = fs.existsSync(busPath)
              ? fs.readFileSync(busPath, "utf8").split(/\r?\n/).map((l) => l.trim()).filter(Boolean)
              : [];

            const busHasStartForIssue = (issue_number) => {
              for (let i = busLines.length - 1; i >= 0; i--) {
                try {
                  const j = JSON.parse(busLines[i]);
                  if (j?.signal_type === "phosphene.hopper.product-strategy.start.v1" && Number(j.issue_number || 0) === Number(issue_number)) {
                    return true;
                  }
                } catch {}
              }
              return false;
            };

            let didAppend = false;
            const appendedIssues = [];

            for (const raw of addedLines) {
              let trigger;
              try { trigger = JSON.parse(raw); } catch { continue; }
              if (String(trigger.signal_type || "") !== "phosphene.autoscribe.product-strategy.issue_created.v1") continue;

              const issue_number = Number(trigger.issue_number || 0);
              const parent_signal_id = String(trigger.signal_id || "").trim();
              if (!issue_number) continue;

              if (busHasStartForIssue(issue_number)) {
                core.notice(`PHOSPHENE: already started for issue #${issue_number} (bus has start signal).`);
                continue;
              }

              const resp = await github.rest.issues.get({ owner, repo, issue_number });
              const issue = resp.data;
              if (!issue?.number) continue;

              const title = String(issue.title || "").trim();
              const body = String(issue.body || "");
              const state = String(issue.state || "").toLowerCase();
              const labels = (issue.labels || [])
                .map((l) => (typeof l === "string" ? l : l?.name))
                .filter(Boolean)
                .map((s) => String(s));
              const labelSet = new Set(labels.map((s) => s.toLowerCase()));

              const reportLines = [
                `${MARKER_REPORT}`,
                "",
                `- **Issue**: #${issue_number}`,
                `- **Trigger**: \`phosphene.autoscribe.product-strategy.issue_created.v1\``,
                `- **Instrument**: \`phosphene:instrument:hopper\``,
                `- **Domain label present**: ${labelSet.has("phosphene:domain:product-strategy") ? "YES" : "NO"}`,
                `- **Ready label present**: ${labelSet.has("phosphene:ready") ? "YES" : "NO"}`,
                `- **Blocked/Hold**: ${(labelSet.has("phosphene:blocked") || labelSet.has("phosphene:hold")) ? "YES" : "NO"}`,
              ];

              if (state !== "open") {
                reportLines.push(`- **Eligible**: NO (state=${state})`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              if (!labelSet.has("phosphene:domain:product-strategy")) {
                reportLines.push(`- **Eligible**: NO (missing domain label)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const rawBlock = extractBlock(body);
              if (!rawBlock) {
                reportLines.push(`- **Eligible**: NO (missing [PHOSPHENE] block)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }
              if (isInformalBlock(rawBlock)) {
                reportLines.push(`- **Eligible**: NO ([PHOSPHENE] is INFORMAL)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const parsed = parseStrictBlock(rawBlock);
              if (parsed.errors.length > 0) {
                reportLines.push(`- **Eligible**: NO (invalid [PHOSPHENE] block: ${parsed.errors.join("; ")})`);
                reportLines.push("- **Action**: re-emit the upstream trigger so autoscribe regenerates a clean issue.");
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const kv = parsed.kv;
              const lane = String(kv.lane || "").trim().toLowerCase();
              const work_type = String(kv.work_type || "").trim().toLowerCase();
              const work_id = String(kv.work_id || "").trim();
              const intent = String(kv.intent || title || "").trim();
              const depends_on = String(kv.depends_on || "").trim();

              reportLines.push(`- **Lane**: ${lane ? "`" + lane + "`" : "(missing)"}`);
              reportLines.push(`- **Work type**: ${work_type ? "`" + work_type + "`" : "(missing)"}`);
              reportLines.push(`- **Work ID**: ${work_id ? "`" + work_id + "`" : "(missing)"}`);

              if (work_type !== "product-strategy" || lane !== "beryl") {
                reportLines.push(`- **Eligible**: NO (work_type/lane mismatch for product-strategy)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const isReady = labelSet.has("phosphene:ready");
              const isBlocked = labelSet.has("phosphene:blocked") || labelSet.has("phosphene:hold");
              if (!isReady || isBlocked) {
                reportLines.push(`- **Eligible**: NO (not ready or blocked)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              if (depends_on) {
                reportLines.push(`- **Eligible**: NO (depends_on set)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              if (!work_id) {
                reportLines.push(`- **Eligible**: NO (missing work_id)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const created_utc = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
              const output_key = `hopper:start:product-strategy:issue:${issue_number}`;

              const hashArgs = [
                "phosphene/phosphene-core/bin/signal_hash.sh",
                "signal-id",
                "--run-marker",
                work_id,
                "--output-key",
                output_key,
              ];
              if (parent_signal_id) hashArgs.push("--parent", parent_signal_id);
              const signal_id = String(execFileSync("bash", hashArgs, { encoding: "utf8" })).trim();

              const signal = {
                signal_version: 1,
                signal_id,
                signal_type: "phosphene.hopper.product-strategy.start.v1",
                work_id,
                domain: "product-strategy",
                issue_number,
                lane,
                intent,
                phos_id: "",
                parents: parent_signal_id ? [parent_signal_id] : [],
                run_marker: work_id,
                output_key,
                created_utc,
              };

              execFileSync("bash", [
                "phosphene/phosphene-core/bin/signal_bus.sh",
                "append",
                "--bus",
                busPath,
                "--line",
                JSON.stringify(signal),
              ], { stdio: "inherit" });

              didAppend = true;
              appendedIssues.push(String(issue_number));
              reportLines.push(`- **Eligible**: YES`);
              reportLines.push(`- **Emitted**: \`phosphene.hopper.product-strategy.start.v1\``);
              await github.rest.issues.createComment({ owner, repo, issue_number, body: [MARKER_STARTED, "", ...reportLines].join("\n") });
            }

            if (didAppend) {
              core.setOutput("did_append", "1");
              core.setOutput("issues", appendedIssues.join(","));
            }

      - name: Commit + push bus append
        if: steps.decide.outputs.did_append == '1'
        shell: bash
        run: |
          set -euo pipefail

          export PHOSPHENE_GANTRY_WRITE_ALLOWLIST=$'phosphene/signals/**\nphosphene/signals/indexes/**'
          bash phosphene/phosphene-core/bin/gantry_write_allowlist_guard.sh check

          if [[ -z "${PHOSPHENE_HUMAN_TOKEN:-}" ]]; then
            echo "PHOSPHENE: missing PHOSPHENE_HUMAN_TOKEN; refusing to push bus changes (would suppress downstream workflows)."
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${PHOSPHENE_HUMAN_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git add "phosphene/signals/bus.jsonl"
          git commit -m "PHOSPHENE: hopper product-strategy start for issue(s) ${{ steps.decide.outputs.issues }}"
          git push origin HEAD:main
