name: "gantry.hopper.global"

on:
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write # comment-only by policy (no edits/labels/state)

env:
  # Gantry write boundary (when/if enabled): signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**

concurrency:
  group: instrument-hopper-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  interpret:
    runs-on: ubuntu-latest
    steps:
      - name: Interpret issue and maybe start work
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue = context.payload.issue;
            if (!issue?.number) return;
            const issue_number = issue.number;

            const MARKER_STARTED = "PHOSPHENE-HOPPER:WORK-STARTED";
            const MARKER_REPORT = "PHOSPHENE-HOPPER:REPORT";
            const MARKER_AUTOSCRIBE_REQUESTED = "PHOSPHENE-HOPPER:AUTOSCRIBE-REQUESTED";

            const isBotUser = (u) => {
              const login = (u?.login || "").toLowerCase();
              return Boolean(u?.type === "Bot" || login.endsWith("[bot]") || login === "github-actions");
            };

            const PH_OPEN = "[PHOSPHENE]";
            const PH_CLOSE = "[/PHOSPHENE]";

            const extractPhospheneBlock = (text) => {
              const openIdx = text.indexOf(PH_OPEN);
              if (openIdx === -1) return null;
              const closeIdx = text.indexOf(PH_CLOSE, openIdx);
              if (closeIdx === -1) return null;
              const raw = text.slice(openIdx, closeIdx + PH_CLOSE.length);
              return raw;
            };

            const REQUIRED_KEYS = [
              "lane",
              "work_type",
              "work_id",
              "intent",
              "depends_on",
              "sequence",
              "upstream_signal_id",
            ];

            const parseStrictBlock = (rawBlock) => {
              const kv = {};
              const errors = [];
              const lines = rawBlock.split(/\r?\n/).slice(1, -1);

              if (lines.length !== REQUIRED_KEYS.length) {
                errors.push(`expected ${REQUIRED_KEYS.length} lines, found ${lines.length}`);
              }

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const m = line.match(/^\s*([a-zA-Z_]+)\s*:\s*(.*?)\s*$/);
                if (!m) {
                  errors.push(`line ${i + 1} is not key:value`);
                  continue;
                }
                const key = m[1].toLowerCase();
                const value = String(m[2] || "").trim();
                const expected = REQUIRED_KEYS[i];
                if (key !== expected) {
                  errors.push(`line ${i + 1} expected key "${expected}", got "${key}"`);
                  continue;
                }
                if (["lane", "work_type", "work_id", "intent"].includes(key) && !value) {
                  errors.push(`"${key}" must be non-empty`);
                }
                kv[key] = value;
              }

              return { kv, errors };
            };

            const isInformalBlock = (rawBlock) => {
              return /(^|\n)\s*informal\s*(\n|$)/i.test(String(rawBlock || ""));
            };

            const requestAutoscribeFix = async (reason, reportLine) => {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number,
                per_page: 100,
              });
              const alreadyRequested = comments.some((c) => String(c.body || "").includes(MARKER_AUTOSCRIBE_REQUESTED));
              if (!alreadyRequested) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: [
                    `${MARKER_AUTOSCRIBE_REQUESTED}`,
                    "",
                    `PHOSPHENE HOPPER: ${reason}`,
                    "Bus-only policy: re-emit the upstream trigger so autoscribe regenerates a clean issue.",
                  ].join("\n"),
                });
              }
              if (reportLine) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: `${MARKER_REPORT}\n${reportLine}`,
                });
              }
            };

            // --- 0) Optional command invocation gate (comments)
            const forceReport = false;
            const forceStart = false;

            // --- 1) Read core record fields
            const title = String(issue.title || "").trim();
            const body = String(issue.body || "");
            const state = String(issue.state || "").toLowerCase();
            const labels = (issue.labels || [])
              .map((l) => (typeof l === "string" ? l : l?.name))
              .filter(Boolean)
              .map((s) => String(s));
            const labelSet = new Set(labels.map((s) => s.toLowerCase()));

            // Domain hoppers own domain-labelled issues. Global hopper ignores them to avoid duplicate starts.
            const domainLabels = labels.map((s) => String(s).toLowerCase()).filter((s) => s.startsWith("phosphene:domain:"));
            if (domainLabels.length > 0 && !domainLabels.includes("phosphene:domain:global")) {
              if (forceReport) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: `${MARKER_REPORT}\nDomain-labelled issue (${domainLabels.join(", ")}). Global hopper is noop.`,
                });
              }
              return;
            }

            // Policy: never start closed issues.
            if (state !== "open") {
              if (forceReport) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: `${MARKER_REPORT}\nIssue state is \`${state}\`. No action.`,
                });
              }
              return;
            }

            // --- 2) Parse canonical [PHOSPHENE] block (strict; no heuristics)
            const rawBlock = extractPhospheneBlock(body);
            if (!rawBlock) {
              await requestAutoscribeFix(
                "missing canonical `[PHOSPHENE] ... [/PHOSPHENE]` block; requesting autoscribe to normalize.",
                forceReport ? `Missing required \`${PH_OPEN}\` block. Autoscribe has been requested.` : null
              );
              return;
            }

            // Valid but noop: INFORMAL block means "do not interpret / do not start".
            if (isInformalBlock(rawBlock)) {
              if (forceReport) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: [
                    `${MARKER_REPORT}`,
                    "",
                    "- **Eligible**: NO",
                    "- **Reason**: `[PHOSPHENE]` block is `INFORMAL` (explicit noop).",
                  ].join("\n"),
                });
              }
              return;
            }

            const parsed = parseStrictBlock(rawBlock);
            if (parsed.errors.length > 0) {
              await requestAutoscribeFix(
                `invalid [PHOSPHENE] block (strict schema): ${parsed.errors.join("; ")}`,
                forceReport ? `Invalid [PHOSPHENE] block (strict schema): ${parsed.errors.join("; ")}` : null
              );
              return;
            }

            const kv = parsed.kv;
            const lane = String(kv.lane || "").trim().toLowerCase();
            const intent = String(kv.intent || title || "(no intent)").trim();

            // Dependencies (optional): parse issue numbers from block `depends_on: ...`
            const depNums = (() => {
              const rhs = String(kv.depends_on || "").trim();
              if (!rhs) return [];
              const out = new Set();
              const candidates = rhs.match(/#?\d+/g) || [];
              for (const c of candidates) {
                const n = Number(String(c).replace("#", ""));
                if (Number.isFinite(n) && n > 0) out.add(n);
              }
              return Array.from(out).sort((a, b) => a - b);
            })();

            // Ready gate:
            //  - automatic start requires label phosphene:ready (unless forceStart)
            const isReady = labelSet.has("phosphene:ready");
            const isBlocked = labelSet.has("phosphene:blocked") || labelSet.has("phosphene:hold");

            // --- 3) Idempotency: if we've already started, do nothing
            const hasStarted = async () => {
              // Scan recent comments for marker.
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number,
                per_page: 100,
              });
              return comments.some((c) => String(c.body || "").includes(MARKER_STARTED));
            };

            if (!forceStart && (await hasStarted())) {
              if (forceReport) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: `${MARKER_REPORT}\nAlready started (found \`${MARKER_STARTED}\`). No action.`,
                });
              }
              return;
            }

            // --- 4) Dependency evaluation (supreme interpreter lives here)
            const depStatus = [];
            let depsOk = true;
            for (const n of depNums) {
              try {
                const dep = await github.rest.issues.get({ owner, repo, issue_number: n });
                const depIssue = dep.data;
                const depState = String(depIssue.state || "").toLowerCase();
                const depLabels = (depIssue.labels || [])
                  .map((l) => (typeof l === "string" ? l : l?.name))
                  .filter(Boolean)
                  .map((s) => String(s).toLowerCase());
                const done = depState === "closed" || depLabels.includes("phosphene:done");
                depStatus.push({ n, done, state: depState });
                if (!done) depsOk = false;
              } catch (e) {
                depStatus.push({ n, done: false, state: "unknown" });
                depsOk = false;
              }
            }

            // --- 5) Eligibility decision
            const eligible =
              !isBlocked &&
              (forceStart || isReady) &&
              (forceStart || depsOk) &&
              (lane === "beryl" || lane === "cerulean") &&
              intent.length > 0;

            const reportLines = [
              `${MARKER_REPORT}`,
              "",
              `- **Eligible**: ${eligible ? "YES" : "NO"}`,
              `- **Lane**: ${lane ? "`" + lane + "`" : "(missing in [PHOSPHENE] block)"}`,
              `- **Ready label present**: ${isReady ? "YES" : "NO"}`,
              `- **Blocked/Hold**: ${isBlocked ? "YES" : "NO"}`,
              `- **Dependencies**: ${depNums.length ? depNums.map((n) => `#${n}`).join(", ") : "(none)"}`,
            ];
            if (depStatus.length) {
              reportLines.push("", "Dependency status:");
              for (const d of depStatus) {
                reportLines.push(`- #${d.n}: ${d.done ? "DONE" : "NOT DONE"} (state=${d.state})`);
              }
            }

            if (!eligible) {
              // Only spam a report when manually invoked; otherwise stay quiet.
              if (forceReport) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: reportLines.join("\n"),
                });
              }
              return;
            }

            // --- 6) Start work by activating a Prism via the canonical /phosphene comment.
            // Prism contract: first line is the command; remainder is context.
            const cmd = `/phosphene ${lane} ${intent}`.trim();
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: [
                cmd,
                "",
                `${MARKER_STARTED}`,
                "",
                "PHOSPHENE HOPPER: starting work by issuing a prism summon based on issue state/config.",
                "",
                `- **Lane**: \`${lane}\``,
                `- **Intent**: ${intent}`,
                depNums.length ? `- **Dependencies**: ${depNums.map((n) => `#${n}`).join(", ")}` : `- **Dependencies**: (none)`,
              ].join("\n"),
            });

            // Optional: if manually invoked, also post the report for transparency.
            if (forceReport) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: reportLines.join("\n"),
              });
            }

