name: "gantry.hopper.ideation"

on:
  push:
    branches: [main]
    paths:
      - "phosphene/signals/bus.jsonl"
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to evaluate"
        required: false
        type: number

permissions:
  contents: write
  issues: write

env:
  # Gantry write boundary: signal bus only.
  PHOSPHENE_GANTRY_WRITE_ALLOWLIST: |
    phosphene/signals/**
    phosphene/signals/indexes/**
  PHOSPHENE_HUMAN_TOKEN: ${{ secrets.PHOSPHENE_HUMAN_TOKEN }}

concurrency:
  group: instrument-hopper-ideation-${{ inputs.issue_number || github.sha || github.run_id }}
  cancel-in-progress: true

jobs:
  interpret:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v5
        with:
          ref: main
          fetch-depth: 0
          persist-credentials: false

      - name: Decide + append start signal (if eligible)
        id: decide
        uses: actions/github-script@v7
        with:
          script: |
            const { execFileSync } = require("child_process");
            const fs = require("fs");
            const crypto = require("crypto");
            const { owner, repo } = context.repo;
            const busPath = "phosphene/signals/bus.jsonl";
            const addedLines = [];

            if (context.eventName === "push") {
              const before = String(context.payload.before || "").trim();
              const after = String(context.sha || "").trim();
              if (!before || !after) return;
              const cmd = [
                "bash",
                "-lc",
                [
                  `bus="${busPath}"`,
                  `git diff --unified=0 "${before}" "${after}" -- "${busPath}" \\`,
                  `  | grep -E '^\\+' \\`,
                  `  | grep -vE '^\\+\\+\\+' \\`,
                  `  | sed -E 's/^\\+//' \\`,
                  `  | grep -E '^\\{' || true`,
                ].join("\n"),
              ];
              const out = String(execFileSync(cmd[0], cmd.slice(1), { encoding: "utf8" }) || "");
              for (const line of out.split(/\r?\n/)) {
                const t = line.trim();
                if (t) addedLines.push(t);
              }
            } else if (context.eventName === "workflow_dispatch") {
              // Manual: evaluate a specific issue (no bus trigger required).
              const raw = String(core.getInput("issue_number") || "").trim();
              if (!raw) {
                core.notice("PHOSPHENE: workflow_dispatch requires issue_number for hopper manual evaluation.");
                return;
              }
              const issue_number = Number(raw);
              addedLines.push(JSON.stringify({
                signal_type: "phosphene.autoscribe.ideation.issue_created.v1",
                issue_number,
                signal_id: "",
              }));
            } else {
              return;
            }

            const MARKER_STARTED = "PHOSPHENE-HOPPER-IDEATION:START-SIGNAL-EMITTED";
            const MARKER_REPORT = "PHOSPHENE-HOPPER-IDEATION:REPORT";
            const SPARK_DIR = "phosphene/signals/sparks";

            const PH_OPEN = "[PHOSPHENE]";
            const PH_CLOSE = "[/PHOSPHENE]";
            const extractBlock = (text) => {
              const openIdx = text.indexOf(PH_OPEN);
              if (openIdx === -1) return null;
              const closeIdx = text.indexOf(PH_CLOSE, openIdx);
              if (closeIdx === -1) return null;
              return text.slice(openIdx, closeIdx + PH_CLOSE.length);
            };
            const REQUIRED_KEYS = [
              "lane",
              "work_type",
              "work_id",
              "intent",
              "depends_on",
              "sequence",
              "upstream_signal_id",
              "manifold_probe_count",
              "seed_sha256",
            ];

            const parseStrictBlock = (rawBlock) => {
              const kv = {};
              const errors = [];
              const lines = rawBlock.split(/\r?\n/).slice(1, -1);

              if (lines.length !== REQUIRED_KEYS.length) {
                errors.push(`expected ${REQUIRED_KEYS.length} lines, found ${lines.length}`);
              }

              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const m = line.match(/^\s*([a-zA-Z0-9_]+)\s*:\s*(.*?)\s*$/);
                if (!m) {
                  errors.push(`line ${i + 1} is not key:value`);
                  continue;
                }
                const key = m[1].toLowerCase();
                const value = String(m[2] || "").trim();
                const expected = REQUIRED_KEYS[i];
                if (key !== expected) {
                  errors.push(`line ${i + 1} expected key "${expected}", got "${key}"`);
                  continue;
                }
                if (["lane", "work_type", "work_id", "intent", "manifold_probe_count", "seed_sha256"].includes(key) && !value) {
                  errors.push(`"${key}" must be non-empty`);
                }
                if (key === "manifold_probe_count") {
                  const parsedCount = Number.parseInt(value, 10);
                  if (!Number.isFinite(parsedCount) || parsedCount < 2) {
                    errors.push(`"manifold_probe_count" must be an integer >= 2`);
                  }
                }
                if (key === "seed_sha256" && value && !/^(sha256:)?[0-9a-f]{64}$/i.test(value)) {
                  errors.push(`"seed_sha256" must be <hex> (optional sha256: prefix)`);
                }
                kv[key] = value;
              }

              return { kv, errors };
            };
            const isInformalBlock = (rawBlock) => /(^|\n)\s*informal\s*(\n|$)/i.test(String(rawBlock || ""));

            const extractInputsBlock = (text) => {
              const open = "[PHOSPHENE_INPUTS]";
              const close = "[/PHOSPHENE_INPUTS]";
              const idx = text.indexOf(open);
              if (idx === -1) return [];
              const end = text.indexOf(close, idx + open.length);
              if (end === -1) return [];
              const body = text.slice(idx + open.length, end);
              const tokens = [];
              for (const rawLine of body.split(/\r?\n/)) {
                const line = rawLine.replace(/^\s*-\s*/, "").trim();
                if (!line) continue;
                for (const t of line.split(/[,\s]+/)) {
                  if (/^[A-Z]{2,}-[0-9]{3,4}$/.test(t)) tokens.push(t);
                }
              }
              return Array.from(new Set(tokens));
            };

            const busLines = fs.existsSync(busPath)
              ? fs.readFileSync(busPath, "utf8").split(/\r?\n/).map((l) => l.trim()).filter(Boolean)
              : [];

            const busHasStartForIssue = (issue_number) => {
              for (let i = busLines.length - 1; i >= 0; i--) {
                try {
                  const j = JSON.parse(busLines[i]);
                  if (j?.signal_type === "phosphene.hopper.ideation.start.v1" && Number(j.issue_number || 0) === Number(issue_number)) {
                    return true;
                  }
                } catch {}
              }
              return false;
            };

            const busHasSparkForIssue = (issue_number) => {
              for (let i = busLines.length - 1; i >= 0; i--) {
                try {
                  const j = JSON.parse(busLines[i]);
                  if (j?.signal_type === "phosphene.hopper.ideation.spark_created.v1" && Number(j.issue_number || 0) === Number(issue_number)) {
                    return true;
                  }
                } catch {}
              }
              return false;
            };

            let didAppend = false;
            const appendedIssues = [];

            for (const raw of addedLines) {
              let trigger;
              try { trigger = JSON.parse(raw); } catch { continue; }
              if (String(trigger.signal_type || "") !== "phosphene.autoscribe.ideation.issue_created.v1") continue;

              const issue_number = Number(trigger.issue_number || 0);
              const parent_signal_id = String(trigger.signal_id || "").trim();
              if (!issue_number) continue;

              if (busHasStartForIssue(issue_number)) {
                core.notice(`PHOSPHENE: already started for issue #${issue_number} (bus has start signal).`);
                continue;
              }

              const resp = await github.rest.issues.get({ owner, repo, issue_number });
              const issue = resp.data;
              if (!issue?.number) continue;

              const title = String(issue.title || "").trim();
              const body = String(issue.body || "");
              const state = String(issue.state || "").toLowerCase();
              const labels = (issue.labels || [])
                .map((l) => (typeof l === "string" ? l : l?.name))
                .filter(Boolean)
                .map((s) => String(s));
              const labelSet = new Set(labels.map((s) => s.toLowerCase()));

              const reportLines = [
                `${MARKER_REPORT}`,
                "",
                `- **Issue**: #${issue_number}`,
                `- **Trigger**: \`phosphene.autoscribe.ideation.issue_created.v1\``,
                `- **Instrument**: \`phosphene:instrument:hopper\``,
                `- **Domain label present**: ${labelSet.has("phosphene:domain:ideation") ? "YES" : "NO"}`,
                `- **Ready label present**: ${labelSet.has("phosphene:ready") ? "YES" : "NO"}`,
                `- **Blocked/Hold**: ${(labelSet.has("phosphene:blocked") || labelSet.has("phosphene:hold")) ? "YES" : "NO"}`,
              ];

              if (state !== "open") {
                reportLines.push(`- **Eligible**: NO (state=${state})`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              if (!labelSet.has("phosphene:domain:ideation")) {
                reportLines.push(`- **Eligible**: NO (missing domain label)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const rawBlock = extractBlock(body);
              if (!rawBlock) {
                reportLines.push(`- **Eligible**: NO (missing [PHOSPHENE] block)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }
              if (isInformalBlock(rawBlock)) {
                reportLines.push(`- **Eligible**: NO ([PHOSPHENE] is INFORMAL)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const parsed = parseStrictBlock(rawBlock);
              if (parsed.errors.length > 0) {
                reportLines.push(`- **Eligible**: NO (invalid [PHOSPHENE] block: ${parsed.errors.join("; ")})`);
                reportLines.push("- **Action**: re-emit the upstream trigger so autoscribe regenerates a clean issue.");
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const kv = parsed.kv;
              const lane = String(kv.lane || "").trim().toLowerCase();
              const work_type = String(kv.work_type || "").trim().toLowerCase();
              const work_id = String(kv.work_id || "").trim();
              const intent = String(kv.intent || title || "").trim();
              const depends_on = String(kv.depends_on || "").trim();
              const sequence = String(kv.sequence || "").trim();
              const upstream_signal_id = String(kv.upstream_signal_id || "").trim();
              const manifold_probe_count = Number.parseInt(String(kv.manifold_probe_count || "").trim(), 10);
              const seed_sha256 = String(kv.seed_sha256 || "").trim();

              reportLines.push(`- **Lane**: ${lane ? "`" + lane + "`" : "(missing)"}`);
              reportLines.push(`- **Work type**: ${work_type ? "`" + work_type + "`" : "(missing)"}`);
              reportLines.push(`- **Work ID**: ${work_id ? "`" + work_id + "`" : "(missing)"}`);
              reportLines.push(`- **Manifold probe count**: ${Number.isFinite(manifold_probe_count) ? "`" + manifold_probe_count + "`" : "(missing)"}`);
              reportLines.push(`- **SeedSHA256**: ${seed_sha256 ? "`" + seed_sha256 + "`" : "(missing)"}`);

              if (work_type !== "ideation" || lane !== "viridian") {
                reportLines.push(`- **Eligible**: NO (work_type/lane mismatch for ideation)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const isReady = labelSet.has("phosphene:ready");
              const isBlocked = labelSet.has("phosphene:blocked") || labelSet.has("phosphene:hold");
              if (!isReady || isBlocked) {
                reportLines.push(`- **Eligible**: NO (not ready or blocked)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              if (depends_on) {
                reportLines.push(`- **Eligible**: NO (depends_on set)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              if (!work_id) {
                reportLines.push(`- **Eligible**: NO (missing work_id)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              if (!Number.isFinite(manifold_probe_count) || manifold_probe_count < 2) {
                reportLines.push(`- **Eligible**: NO (manifold_probe_count must be >= 2)`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const seedInputValues = [
                lane,
                work_type,
                work_id,
                intent,
                depends_on,
                sequence,
                upstream_signal_id,
                String(manifold_probe_count),
              ].join("\n");
              const expectedSeedHex = crypto.createHash("sha256").update(seedInputValues).digest("hex");
              const expectedSeedPrefixed = `sha256:${expectedSeedHex}`;
              if (seed_sha256 !== expectedSeedHex && seed_sha256 !== expectedSeedPrefixed) {
                reportLines.push(`- **Eligible**: NO (seed_sha256 mismatch; expected ${expectedSeedHex})`);
                await github.rest.issues.createComment({ owner, repo, issue_number, body: reportLines.join("\n") });
                continue;
              }

              const sparkId = `SPARK-${String(issue_number).padStart(6, "0")}`;
              const sparkPath = `${SPARK_DIR}/${sparkId}.md`;
              const inputWorkIds = extractInputsBlock(body);

              if (!fs.existsSync(SPARK_DIR)) {
                fs.mkdirSync(SPARK_DIR, { recursive: true });
              }
              if (!fs.existsSync(sparkPath)) {
                const created_utc_spark = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
                const sparkHeader = [
                  `ID: ${sparkId}`,
                  `IssueNumber: ${issue_number}`,
                  `WorkID: ${work_id}`,
                  `Lane: ${lane}`,
                  `UpstreamSignalID: ${parent_signal_id || ""}`,
                  `InputWorkIDs: ${inputWorkIds.join(",")}`,
                  `ManifoldProbeCount: ${manifold_probe_count}`,
                  `SeedSHA256: ${seed_sha256}`,
                  `CreatedUTC: ${created_utc_spark}`,
                  "",
                  "## Issue snapshot",
                  "",
                ].join("\n");
                fs.writeFileSync(sparkPath, `${sparkHeader}${body || ""}\n`, "utf8");
              }

              const created_utc = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
              const output_key = `hopper:start:ideation:issue:${issue_number}`;

              const hashArgs = [
                "phosphene/phosphene-core/bin/signal_hash.sh",
                "signal-id",
                "--run-marker",
                work_id,
                "--output-key",
                output_key,
              ];
              if (parent_signal_id) hashArgs.push("--parent", parent_signal_id);
              const signal_id = String(execFileSync("bash", hashArgs, { encoding: "utf8" })).trim();

              if (!busHasSparkForIssue(issue_number)) {
                const spark_created_utc = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
                const spark_output_key = `hopper:spark-created:ideation:issue:${issue_number}`;
                const spark_hash_args = [
                  "phosphene/phosphene-core/bin/signal_hash.sh",
                  "signal-id",
                  "--run-marker",
                  work_id,
                  "--output-key",
                  spark_output_key,
                ];
                if (parent_signal_id) spark_hash_args.push("--parent", parent_signal_id);
                const spark_signal_id = String(execFileSync("bash", spark_hash_args, { encoding: "utf8" })).trim();
                const spark_signal = {
                  signal_version: 1,
                  signal_id: spark_signal_id,
                  signal_type: "phosphene.hopper.ideation.spark_created.v1",
                  work_id,
                  domain: "ideation",
                  issue_number,
                  lane,
                  spark_id: sparkId,
                  spark_path: sparkPath,
                  manifold_probe_count,
                  seed_sha256,
                  parents: parent_signal_id ? [parent_signal_id] : [],
                  run_marker: work_id,
                  output_key: spark_output_key,
                  created_utc: spark_created_utc,
                };
                execFileSync("bash", [
                  "phosphene/phosphene-core/bin/signal_bus.sh",
                  "append",
                  "--bus",
                  busPath,
                  "--line",
                  JSON.stringify(spark_signal),
                ], { stdio: "inherit" });
              }

              const signal = {
                signal_version: 1,
                signal_id,
                signal_type: "phosphene.hopper.ideation.start.v1",
                work_id,
                domain: "ideation",
                issue_number,
                lane,
                intent,
                spark_id: sparkId,
                spark_path: sparkPath,
                manifold_probe_count,
                seed_sha256,
                phos_id: "",
                parents: parent_signal_id ? [parent_signal_id] : [],
                run_marker: work_id,
                output_key,
                created_utc,
              };

              execFileSync("bash", [
                "phosphene/phosphene-core/bin/signal_bus.sh",
                "append",
                "--bus",
                busPath,
                "--line",
                JSON.stringify(signal),
              ], { stdio: "inherit" });

              didAppend = true;
              appendedIssues.push(String(issue_number));
              reportLines.push(`- **Eligible**: YES`);
              reportLines.push(`- **Emitted**: \`phosphene.hopper.ideation.start.v1\``);
              reportLines.push(`- **SPARK**: \`${sparkId}\``);
              reportLines.push(`- **SPARK path**: \`${sparkPath}\``);
              await github.rest.issues.createComment({ owner, repo, issue_number, body: [MARKER_STARTED, "", ...reportLines].join("\n") });
            }

            if (didAppend) {
              core.setOutput("did_append", "1");
              core.setOutput("issues", appendedIssues.join(","));
            }

      - name: Commit + push bus append
        if: steps.decide.outputs.did_append == '1'
        shell: bash
        run: |
          set -euo pipefail

          export PHOSPHENE_GANTRY_WRITE_ALLOWLIST=$'phosphene/signals/**\nphosphene/signals/indexes/**'
          bash phosphene/phosphene-core/bin/gantry_write_allowlist_guard.sh check

          if [[ -z "${PHOSPHENE_HUMAN_TOKEN:-}" ]]; then
            echo "PHOSPHENE: missing PHOSPHENE_HUMAN_TOKEN; refusing to push bus changes (would suppress downstream workflows)."
            exit 1
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${PHOSPHENE_HUMAN_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          git add "phosphene/signals/bus.jsonl"
          git add "phosphene/signals/sparks"
          git commit -m "PHOSPHENE: hopper ideation start for issue(s) ${{ steps.decide.outputs.issues }}"
          git push origin HEAD:main
